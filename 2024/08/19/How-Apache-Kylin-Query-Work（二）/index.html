<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="Guoliang"><meta name="keywords" content=""><title>How Apache Kylin Query Work（二） - Guoliang&#39;s Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/a11y-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:80,cursorChar:"乄",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"always",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"gffo4y4h3e1D9tHT2ADcTxtp-gzGzoHsz",app_key:"EaplHXnXAqIYs5wCxGMVB4l4",server_url:"https://gffo4y4h.lc-cn-n1-shared.com"}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>步尽白</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/pingan.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="How Apache Kylin Query Work（二）"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Guoliang </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-08-19 16:00" pubdate>2024年8月19日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 21 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">How Apache Kylin Query Work（二）</h1><p class="note note-info">本文最后更新于：2025年1月23日 下午</p><div class="markdown-body"><h1 id="FYI"><a href="#FYI" class="headerlink" title="FYI"></a>FYI</h1><p>全文仅关注逻辑主体代码，其他代码均省略。</p><ul><li>repo：<a target="_blank" rel="noopener" href="https://github.com/apache/kylin">https://github.com/apache/kylin</a></li><li>branch：kylin5</li><li>commitMessage：KYLIN-5943 Upgrade spark to 3.3.0-kylin-4.6.26.0</li><li>commitID：77201e7bcddb605da56e7f00d39db82e8f2d8931</li></ul><h1 id="Query-Entrance"><a href="#Query-Entrance" class="headerlink" title="Query Entrance"></a>Query Entrance</h1><p>我们跳过其他部分，直接进入 Kylin 查询真正处理的核心入口 <code>QueryExec#executeQuery</code>。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> QueryResult <span class="hljs-title function_">executeQuery</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;
	<span class="hljs-type">RelRoot</span> <span class="hljs-variable">relRoot</span> <span class="hljs-operator">=</span> sqlConverter.convertSqlToRelNode(sql);
	<span class="hljs-type">RelNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queryOptimizer.optimize(relRoot).rel;
	<span class="hljs-type">QueryResult</span> <span class="hljs-variable">queryResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryResult</span>(executeQueryPlan(postOptimize(node)), resultFields);
&#125;</code></pre></div><h1 id="Calcite"><a href="#Calcite" class="headerlink" title="Calcite"></a>Calcite</h1><p>在模型匹配前的查询逻辑都是在 Calcite 中进行处理的。</p><h2 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h2><p>这一过程为后续 Calcite 的元数据 Schema 以及查询阶段使用的优化规则做了准备，参考 QueryExec 的构造方法</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">QueryExec</span><span class="hljs-params">(String project, KylinConfig kylinConfig, <span class="hljs-type">boolean</span> allowAlternativeQueryPlan)</span> &#123;  
    <span class="hljs-built_in">this</span>.project = project;  
    <span class="hljs-built_in">this</span>.kylinConfig = kylinConfig;  
    connectionConfig = KylinConnectionConfig.fromKapConfig(kylinConfig);  
    schemaFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProjectSchemaFactory</span>(project, kylinConfig);  
    rootSchema = schemaFactory.createProjectRootSchema();  
    <span class="hljs-type">String</span> <span class="hljs-variable">defaultSchemaName</span> <span class="hljs-operator">=</span> schemaFactory.getDefaultSchema();  
    catalogReader = SqlConverter.createCatalogReader(connectionConfig, rootSchema, defaultSchemaName);  
    planner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PlannerFactory</span>(kylinConfig).createVolcanoPlanner(connectionConfig);  
    sqlConverter = QueryExec.createConverter(connectionConfig, planner, catalogReader);  
    dataContext = createDataContext(rootSchema);  
    planner.setExecutor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RexExecutorImpl</span>(dataContext));  
    queryOptimizer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryOptimizer</span>(planner);
&#125;</code></pre></div><p>注意这里的 planner 是 Kylin 在 CBO 阶段用到的优化规则，包含 Calcite 默认提供的一些优化规则，以及 Kylin 自己实现的优化规则，需要说明的是 Kylin 通过 CBO 阶段将 Calcite 通过 Schema 校验后的查询逻辑计划首先转变为自定义的 Olap Convension 逻辑计划，这之后还会经过一次 RBO 阶段优化才会转为可执行的物理执行计划。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> VolcanoPlanner <span class="hljs-title function_">createVolcanoPlanner</span><span class="hljs-params">(CalciteConnectionConfig connectionConfig)</span> &#123;  
    <span class="hljs-type">VolcanoPlanner</span> <span class="hljs-variable">planner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolcanoPlanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PlannerContext</span>(connectionConfig));  
    registerDefaultRules(planner);  
    registerCustomRules(planner);  
    <span class="hljs-keyword">return</span> planner;  
&#125;</code></pre></div><p>Kylin 在 CBO 阶段自定义 Rule 大多继承自 Calcite ConverterRule，该抽象类的定义是在不改变语义的情况下，将一种调用约定 Convension 转换为另一种 Convension，如 Kylin 中从默认的 NONE -&gt; OLAP，转换时一般是伴随的关系，如 Kylin 中 OlapProjectRule 将 LogicalProject 转换为 OlapProjectRel，这样就可以在后续对 OlapProjectRel 继续进行转换优化，LogicalXxx 是 Calcite 通过校验后未经优化的查询逻辑计划。</p><p>当 Calcite 执行 CBO 优化完成后，会检查当前查询逻辑计划中是否仍有 NONE 的 RelNode，如果有则说明优化转换没有覆盖到，此时会报错，比如下面就是超过了 CBO 最大重试次数后 LogicalSort 未能成功转换的报错信息。</p><div class="hljs code-wrapper"><pre><code class="hljs java">There are not enough rules to produce a node with desired properties: convention=ENUMERABLE, sort=[<span class="hljs-number">0</span> ASC-nulls-first]. 
Missing conversion is LogicalSort[convention: NONE -&gt; ENUMERABLE]</code></pre></div><h2 id="SQL-gt-AST-gt-RelRoot"><a href="#SQL-gt-AST-gt-RelRoot" class="headerlink" title="SQL -&gt; AST -&gt;  RelRoot"></a>SQL -&gt; AST -&gt; RelRoot</h2><p>对应前文的 <code>sqlConverter.convertSqlToRelNode(sql)</code> 逻辑，这一段首先将 SQL 转换为一棵抽象语法树 AST，Calcite 使用的是 JavaCC，Spark 使用的是 Antlr。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RelRoot <span class="hljs-title function_">convertSqlToRelNode</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SqlParseException &#123;
    <span class="hljs-type">SqlNode</span> <span class="hljs-variable">sqlNode</span> <span class="hljs-operator">=</span> parseSQL(sql);
    <span class="hljs-keyword">return</span> convertToRelNode(sqlNode);
&#125;</code></pre></div><p>转换时涉及到词法分析、语法分析，编写模板是 parser.jj 文件，可以通过在文件中新增定义实现并支持自己的语法。<br>SQL 转换为 SqlNode 之后长这样<br><img src="https://guimy.tech/images/introduction_calcite/sql_node_object.png" srcset="/img/loading.gif" lazyload><br>接着经过一系列的校验以及和元数据信息的绑定，就可以从一棵抽象语法树 AST 变成未经优化的逻辑计划 RelRoot，RelRoot 是一系列查询逻辑计划节点 RelNode 的根节点。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RelRoot <span class="hljs-title function_">convertToRelNode</span><span class="hljs-params">(SqlNode sqlNode)</span> &#123;  
    <span class="hljs-type">RelRoot</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> sqlToRelConverter.convertQuery(sqlNode, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">return</span> root;
&#125;</code></pre></div><p>元数据信息在 Calcite 中称为 Schema，有个抽象类 AbstractSchema，Kylin 的 OlapSchema 继承并实现了该抽象类，这些信息在创建出 sqlConverter 前需要先准备好。</p><h2 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h2><p>我们来看这一段 <code>queryOptimizer.optimize(relRoot)</code>，从这里就开始了对查询逻辑计划的优化操作。<br>这一块包含多处子步骤优化，列举如下</p><ul><li>subQuery</li><li>DecorrelateProgram</li><li>TrimFieldsProgram</li><li>program1</li><li>calc</li></ul><h3 id="subQuery"><a href="#subQuery" class="headerlink" title="subQuery"></a>subQuery</h3><p>Calcite 原生仅有 3 个优化规则，Kylin 在此基础上新增了 OLAPJoinPushThroughJoinRule 和 OLAPJoinPushThroughJoinRule2，这两个规则均改自 Calcite 原生的 JoinPushThroughJoinRule，目的是将带有 join 的子查询下推至表与表的 join 查询逻辑之后，这样方便 Kylin 在使用查询逻辑计划匹配模型时能够匹配上预定义的表 join 关系，OLAPJoinPushThroughJoinRule2 则在此基础上允许循环匹配，需要说明的是 Kylin 创建模型定义的表 join 关系只有 left 和 inner 两种，当 SQL 查询为 right join 时不会作此改写。</p><ul><li>CoreRules.FILTER_SUB_QUERY_TO_CORRELATE</li><li>CoreRules.PROJECT_SUB_QUERY_TO_CORRELATE</li><li>CoreRules.JOIN_SUB_QUERY_TO_CORRELATE</li></ul><p>以一条 SQL 举例说明子查询的可读性，比如查询没有订购物品的消费者信息</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c.c_custkey
<span class="hljs-keyword">FROM</span> customer c
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> c.c_custkey <span class="hljs-operator">=</span> o.o_custkey
<span class="hljs-keyword">WHERE</span> o.o_custkey <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><p>使用子查询的方式改写如下，极大地降低了 SQL 的复杂性</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c_custkey
<span class="hljs-keyword">FROM</span> customer
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (
    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>
    <span class="hljs-keyword">FROM</span> orders
    <span class="hljs-keyword">WHERE</span> o_custkey <span class="hljs-operator">=</span> c_custkey
)</code></pre></div><p>在查询逻辑计划中将连接外部查询和子查询的运算符称为 <code>Correlate</code>，Calcite 通过这些规则将用户写的子查询 SQL 改写为上面的 SQL 在后续逻辑进行处理，这样做更便于进行查询逻辑计划优化。</p><h3 id="DecorrelateProgram"><a href="#DecorrelateProgram" class="headerlink" title="DecorrelateProgram"></a>DecorrelateProgram</h3><p>这一部分和上面消除子查询的优化相互关联，这一过程称为去相关或取消嵌套，去相关的关键是<strong>获得子查询的外部查询对应列值</strong>。当相关连接算子的左右子树没有相关列时，可以将 Correlate join 转换为普通的 join，参考下图，这样就可以像之前一样从下到上进行计算。<br><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*navAQNlGX38i6Hzt.png" srcset="/img/loading.gif" lazyload><br>还有转换为带有 condition 的 Correlate join，参考下图。<br><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pEb3o8oHbCrUUDm4.png" srcset="/img/loading.gif" lazyload><br>还有很多其他转换思路，这里不再一一举例。</p><blockquote><p>FYI：<a target="_blank" rel="noopener" href="https://alibaba-cloud.medium.com/query-optimization-technology-for-correlated-subqueries-8d265a51f58e">Query Optimization Technology for Correlated Subqueries</a></p></blockquote><h3 id="TrimFieldsProgram"><a href="#TrimFieldsProgram" class="headerlink" title="TrimFieldsProgram"></a>TrimFieldsProgram</h3><p>该过程无法通过参数控制，其主要作用是裁剪关系表达式中用不到的字段，在创建新的 RelNode（Calcite 中定义的查询逻辑计划类比 Spark Logical Plan） 同时，也会进行必要的优化，比如对 Filter 条件表达式进行优化，参考如下方法，Calcite 会尝试对表达式进行各种优化：布尔表达式是否返回值始终为 false、常量值是否能直接计算（这部分会进一步使用 <code>RexExecutable</code> 调用 JDK 底层方法直接生成可执行代码）等。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// RelFieldTrimmer#trimFields(Filter, ImmutableBitSet, Set&lt;RelDataTypeField&gt;)</span>
<span class="hljs-keyword">public</span> TrimResult <span class="hljs-title function_">trimFields</span><span class="hljs-params">(  </span>
<span class="hljs-params">    Filter filter,  </span>
<span class="hljs-params">    ImmutableBitSet fieldsUsed,  </span>
<span class="hljs-params">    Set&lt;RelDataTypeField&gt; extraFields)</span> &#123;  
    
  <span class="hljs-comment">// If the input is unchanged, and we need to project all columns,  </span>
  <span class="hljs-comment">// there&#x27;s nothing we can do.  if (newInput == input  </span>
      &amp;&amp; fieldsUsed.cardinality() == fieldCount) &#123;  
    <span class="hljs-keyword">return</span> result(filter, Mappings.createIdentity(fieldCount));  
  &#125;
  
  <span class="hljs-comment">// Build new filter with trimmed input and condition.  </span>
  relBuilder.push(newInput)  
      .filter(filter.getVariablesSet(), newConditionExpr);  
  
  <span class="hljs-comment">// The result has the same mapping as the input gave us. Sometimes we  </span>
  <span class="hljs-comment">// return fields that the consumer didn&#x27;t ask for, because the filter  </span>
  <span class="hljs-comment">// needs them for its condition.  </span>
  <span class="hljs-keyword">return</span> result(relBuilder.build(), inputMapping);  
&#125;</code></pre></div><h3 id="program1"><a href="#program1" class="headerlink" title="program1"></a>program1</h3><p>接下来就到了执行 planner 中预定义好的优化规则这一步，由于前文创建的是 VolcanoPlanner，直接看 <code>VolcanoPlanner#findBestExp</code> 方法。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> RelNode <span class="hljs-title function_">findBestExp</span><span class="hljs-params">()</span> &#123;
  ensureRootConverters();  
  registerMaterializations();  
  
  ruleDriver.drive();
  
  <span class="hljs-type">RelNode</span> <span class="hljs-variable">cheapest</span> <span class="hljs-operator">=</span> root.buildCheapestPlan(<span class="hljs-built_in">this</span>);
  <span class="hljs-keyword">return</span> cheapest;  
&#125;</code></pre></div><p><code>ruleDriver.drive()</code> 是这段逻辑的核心，而 <code>buildCheapestPlan</code> 是将每个逻辑计划中最优也就是代价最低的查询逻辑计划选出来，继续往下分析 drive 方法。</p><p>执行优化匹配时，依次从 ruleQueue 中弹出一条优化规则，首先检查是否符合 <code>matches</code> 的判断条件（默认返回 true），满足条件时再调用优化规则的 <code>onmatch</code> 方法进行处理，<code>onmatch</code> 内部的逻辑涉及优化规则具体的优化步骤和规则对优化前后查询逻辑计划的转换。<code>canonize</code> 方法用于保证始终返回当前查询逻辑计划的根节点。至于计算 cost 并选出 best 查询节点 RelNode 的过程则是在 <code>VolcanoPlanner#setRoot</code> 中进行的，这里均不展开细讲。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;  
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  
    <span class="hljs-keyword">assert</span> planner.root != <span class="hljs-literal">null</span> : <span class="hljs-string">&quot;RelSubset must not be null at this point&quot;</span>;  
    LOGGER.debug(<span class="hljs-string">&quot;Best cost before rule match: &#123;&#125;&quot;</span>, planner.root.bestCost);  
  
    <span class="hljs-type">VolcanoRuleMatch</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> ruleQueue.popMatch();  
    <span class="hljs-keyword">if</span> (match == <span class="hljs-literal">null</span>) &#123;  
      <span class="hljs-keyword">break</span>;  
    &#125;  
  
    <span class="hljs-keyword">assert</span> match.getRule().matches(match);  
    <span class="hljs-keyword">try</span> &#123;  
      match.onMatch();  
    &#125; <span class="hljs-keyword">catch</span> (VolcanoTimeoutException e) &#123;  
      LOGGER.warn(<span class="hljs-string">&quot;Volcano planning times out, cancels the subsequent optimization.&quot;</span>);  
      planner.canonize();  
      <span class="hljs-keyword">break</span>;  
    &#125;  
  
    <span class="hljs-comment">// The root may have been merged with another  </span>
    <span class="hljs-comment">// subset. Find the new root subset.    </span>
    planner.canonize();  
  &#125;  
  
&#125;</code></pre></div><p>这时可能有人会疑问，为什么继承了抽象类 RelOptRule 实现自定义的优化规则，在没有重载 <code>matches</code> 方法的情况下，优化规则却没有匹配进入呢？这是个非常好的问题，和注册优化规则时的逻辑有关系，我们回过头关注一下其构造方法。重点关注变量 <code>RelOptRuleOperand</code>，在传参时甚至会校验该变量值不能为 null。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">RelOptRule</span><span class="hljs-params">(RelOptRuleOperand operand,  </span>
<span class="hljs-params">    RelBuilderFactory relBuilderFactory, <span class="hljs-meta">@Nullable</span> String description)</span> &#123;  
  <span class="hljs-built_in">this</span>.operand = Objects.requireNonNull(operand, <span class="hljs-string">&quot;operand&quot;</span>);
&#125;</code></pre></div><p>结合 <code>RelOptRuleOperand</code> 的 <code>matches</code> 方法和 Kylin 中一个具体的优化规则 <code>OlapAggProjectMergeRule</code> 来举例。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(RelNode rel)</span> &#123;  
  <span class="hljs-keyword">if</span> (!clazz.isInstance(rel)) &#123;  
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  
  &#125;  
  <span class="hljs-keyword">if</span> ((trait != <span class="hljs-literal">null</span>) &amp;&amp; !rel.getTraitSet().contains(trait)) &#123;  
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  
  &#125;  
  <span class="hljs-keyword">return</span> predicate.test(rel);  
&#125;</code></pre></div><p>下面这段是 <code>OlapAggProjectMergeRule</code> 涉及到的方法，可以看到其构造方法传给父类时的 <code>RelOptRuleOperand</code> 包含了多个 RelNode 之间的关系，比如查询逻辑计划符合 <code>agg-project-join</code> 或是 <code>agg-project-filter-join</code> 这样的操作顺序，当触发优化规则执行时，不符合这一条件的优化规则首先就被过滤掉了。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OlapAggProjectMergeRule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RelOptRule</span> &#123;
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">OlapAggProjectMergeRule</span> <span class="hljs-variable">AGG_PROJECT_JOIN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OlapAggProjectMergeRule</span>(  
	        operand(OlapAggregateRel.class, operand(OlapProjectRel.class, operand(OlapJoinRel.class, any()))),  
	        RelFactories.LOGICAL_BUILDER, <span class="hljs-string">&quot;OlapAggProjectMergeRule:agg-project-join&quot;</span>);  
	  
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">OlapAggProjectMergeRule</span> <span class="hljs-variable">AGG_PROJECT_FILTER_JOIN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OlapAggProjectMergeRule</span>(  
	        operand(OlapAggregateRel.class,  
	                operand(OlapProjectRel.class, operand(OlapFilterRel.class, operand(OlapJoinRel.class, any())))),  
	        RelFactories.LOGICAL_BUILDER, <span class="hljs-string">&quot;OlapAggProjectMergeRule:agg-project-filter-join&quot;</span>);  
	  
	<span class="hljs-keyword">public</span> <span class="hljs-title function_">OlapAggProjectMergeRule</span><span class="hljs-params">(RelOptRuleOperand operand, RelBuilderFactory relBuilderFactory, String description)</span> &#123;  
	    <span class="hljs-built_in">super</span>(operand, relBuilderFactory, description);  
	&#125;
&#125;</code></pre></div><h3 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h3><p>这一过程比较特殊，属于可执行的优化规则（指 Convension 由 NONE -&gt; BindableConvention），见 <code>RelOptRules#CALC_RULES</code> ，其顺序如下。执行时同样先检查是否符合优化规则匹配条件，再执行优化操作。</p><div class="hljs code-wrapper"><pre><code class="hljs leaf">HepPlanner<span class="hljs-punctuation">#</span><span class="hljs-keyword">findBestExp</span> -&gt; HepPlanner<span class="hljs-punctuation">#</span><span class="hljs-keyword">executeProgram</span><span class="hljs-params">(<span class="hljs-variable">HepProgram</span>)</span> -&gt; RuleInstance.State<span class="hljs-punctuation">#</span><span class="hljs-keyword">execute</span> -&gt; HepPlanner<span class="hljs-punctuation">#</span><span class="hljs-keyword">applyRules</span> -&gt; HepPlanner<span class="hljs-punctuation">#</span><span class="hljs-keyword">applyRule</span></code></pre></div><h2 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h2><p>经过一系列 CBO 阶段优化规则之后，来到了 RBO 阶段，直接看代码逻辑，见 <code>HepUtils.runRuleCollection</code>。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;RelNode&gt; <span class="hljs-title function_">postOptimize</span><span class="hljs-params">(RelNode node)</span> &#123;  
    Collection&lt;RelOptRule&gt; postOptRules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();  
    <span class="hljs-comment">// It will definitely work if it were put here  </span>
    postOptRules.add(SumConstantConvertRule.INSTANCE);  
    <span class="hljs-keyword">if</span> (kylinConfig.isConvertSumExpressionEnabled()) &#123;  
        postOptRules.addAll(HepUtils.SumExprRules);  
    &#125;  
    <span class="hljs-keyword">if</span> (kylinConfig.isConvertCountDistinctExpressionEnabled()) &#123;  
        postOptRules.addAll(HepUtils.CountDistinctExprRules);  
    &#125;  
  
    <span class="hljs-keyword">if</span> (kylinConfig.isAggregatePushdownEnabled()) &#123;  
        postOptRules.addAll(HepUtils.AggPushDownRules);  
    &#125;  
  
    <span class="hljs-keyword">if</span> (kylinConfig.isScalarSubqueryJoinEnabled()) &#123;  
        postOptRules.addAll(HepUtils.ScalarSubqueryJoinRules);  
    &#125;  
  
    <span class="hljs-keyword">if</span> (kylinConfig.isOptimizedSumCastDoubleRuleEnabled()) &#123;  
        postOptRules.addAll(HepUtils.SumCastDoubleRules);  
    &#125;  
  
    <span class="hljs-keyword">if</span> (kylinConfig.isQueryFilterReductionEnabled()) &#123;  
        postOptRules.addAll(HepUtils.FilterReductionRules);  
    &#125;  
  
    postOptRules.add(OlapFilterJoinRule.FILTER_ON_JOIN);  
    <span class="hljs-comment">// this rule should after sum-expression and count-distinct-expression  </span>
    postOptRules.add(OlapProjectJoinTransposeRule.INSTANCE);  
  
    <span class="hljs-type">RelNode</span> <span class="hljs-variable">transformed</span> <span class="hljs-operator">=</span> HepUtils.runRuleCollection(node, postOptRules, <span class="hljs-literal">false</span>);  
    <span class="hljs-keyword">if</span> (transformed != node &amp;&amp; allowAlternativeQueryPlan) &#123;  
        <span class="hljs-keyword">return</span> Lists.newArrayList(transformed, node);  
    &#125; <span class="hljs-keyword">else</span> &#123;  
        <span class="hljs-keyword">return</span> Lists.newArrayList(transformed);  
    &#125;  
&#125;</code></pre></div><p>RBO 阶段执行优化的逻辑和 CBO 阶段类似，不同的是 RBO 只会按照固定添加的优化规则顺序匹配并依次执行，不会重复进入同样的优化规则（除非添加两次且都符合条件），同时这一阶段也不会计算 cost，这是两者最大的区别。</p><h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><p>模型匹配后的逻辑则是在 Spark 这一层做的，中间省略了模型匹配的过程。</p><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>到这步，就需要将 Calcite 的查询逻辑计划转换为 Spark 的查询逻辑计划，见 <code>CalciteToSparkPlaner#visit</code>。</p><ul><li><p>按照查询计划从下往上依次进行转换</p></li><li><p>转换时跳过 OlapJoinRel/OlapNonEquiJoinRel 且不是 runtime join 的情况，runtime join 指匹配不上索引需要现算</p></li><li><p><code>CalciteToSparkPlaner#convertTableScan</code> 方法在转换 OlapTableScan 和 OlapJoinRel 时都会用到，也就是说对于 join 这种场景，在前面的逻辑成功匹配模型索引后，真正执行时直接扫描两张表已经 join 之后的数据地址即可，无需真正扫描两张表再 join 计算，这些信息在构建模型索引时和数据地址一并存储在模型索引的元数据信息中</p></li><li><p>对于非 admin 用户，在转换完成返回 Spark DataSet 时会对数据做一些其他操作，比如数据脱敏</p></li><li><p>真正执行计算时会判断数据入口，这里会判断是否来自于 MDX 的计算，之前 Kylin 开源过一版和 MDX 的对接，见：<a target="_blank" rel="noopener" href="https://kylin.apache.org/cn/docs/tutorial/quick_start_for_mdx.html">QuickStartForMDX</a> ，MDX 是一种类似 SQL 的查询语法，但其抽象程度比 SQL 更高，拥有类似 Hierarchy 这样的概念，用户多会通过 Excel 使用后台对接 MDX 进行查询，最早由微软开放出来而现在已经放弃了该项目，相对来说用的人很少，市面上资料比较少，门槛也高。之前 Kylin 商业版开发过 MDX on Spark 的项目，主要目的是使 MDX 能够拥有分布式计算的能力，我是该攻坚项目的核心研发之一，项目并未开源。在此基础上，有一种场景是客户使用 Excel 拖拉拽式查询，后台通过 MDX + Kylin -&gt; Calcite/Spark 的方式匹配预计算结果返回，体验还是不错的。</p></li><li><p>查询返回有两种情况</p><ul><li>异步查询：提交异步任务计算，结果保存在 HDFS，一般通过单独的接口调用，mock 虚拟结果直接返回</li><li>即时查询：基于文件大小估算分区数量，记录执行任务的相关信息，在通过大查询校验后（通过扫描行数以及相关配置参数来判断是否拒绝此查询），真正执行计算获得结果</li></ul></li><li><p>查询引擎里的 Spark Driver 和 Kylin Server 在一个常驻进程里，内部将查询的 Spark 称为 Sparder 引擎以区分构建使用的 Spark 引擎</p></li></ul><p>至此， 查询流程模型匹配前的 Calcite 处理和模型匹配后的 Spark 处理部分介绍完毕，后续再补充模型匹配处理流程。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a> <a class="hover-with-bg" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/OLAP/">OLAP</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Kylin/">Kylin</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2025/01/23/How-Apache-Kylin-Query-Work%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">How Apache Kylin Query Work（三）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/07/31/How-Apache-Kylin-Query-Work%EF%BC%88%E4%B8%80%EF%BC%89/"><span class="hidden-mobile">How Apache Kylin Query Work（一）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",(function(){new Valine({el:"#valine",app_id:"gffo4y4h3e1D9tHT2ADcTxtp-gzGzoHsz",app_key:"EaplHXnXAqIYs5wCxGMVB4l4",placeholder:"说点什么",path:window.location.pathname,avatar:"robohash",meta:["nick","mail"],pageSize:"10",lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:""})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><script src="/js/boot.js"></script></body></html>