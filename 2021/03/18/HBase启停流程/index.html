<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="Guoliang"><meta name="keywords" content=""><title>HBase 启停流程 - Guoliang&#39;s Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/a11y-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:80,cursorChar:"乄",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"always",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"gffo4y4h3e1D9tHT2ADcTxtp-gzGzoHsz",app_key:"EaplHXnXAqIYs5wCxGMVB4l4",server_url:"https://gffo4y4h.lc-cn-n1-shared.com"}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>步尽白</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/pingan.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="HBase 启停流程"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Guoliang </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-18 16:43" pubdate>2021年3月18日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 14.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 117 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">HBase 启停流程</h1><p class="note note-info">本文最后更新于：2021年4月17日 上午</p><div class="markdown-body"><h1 id="整体流程分析"><a href="#整体流程分析" class="headerlink" title="整体流程分析"></a>整体流程分析</h1><p>版本：hbase-2.2.4<br>说明：分析展现的源码和脚本中会省略一部分，只保留与分析相关联的，感兴趣的可自行查阅。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="start-hbase-sh"><a href="#start-hbase-sh" class="headerlink" title="start-hbase.sh"></a>start-hbase.sh</h3><p>启动 HBase 的入口，有两种模式：单机模式和集群模式，何种模式取决于用户的配置，下文会详细说明。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前路径，即 &#123;HBASE_HOME&#125;/bin</span>
bin=`dirname &quot;$&#123;BASH_SOURCE-$0&#125;&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载 bin 目录下的 hbase-config.sh 文件</span>
. &quot;$bin&quot;/hbase-config.sh
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">判断加载 hbase-config.sh 是否成功，失败则退出，通常最后命令的退出状态为 0 表示没有错误</span>
errCode=$?
if [ $errCode -ne 0 ]
then
  exit $errCode
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">此处用户一般不传参，所以默认将 start 赋值给 commandToRun</span>
if [ &quot;$1&quot; = &quot;autostart&quot; ]
then
  commandToRun=&quot;--autostart-window-size $&#123;AUTOSTART_WINDOW_SIZE&#125; --autostart-window-retry-limit $&#123;AUTOSTART_WINDOW_RETRY_LIMIT&#125; autostart&quot;
else
  commandToRun=&quot;start&quot;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">通过 HBase 源码中的 HBaseConfTool 获取 conf/hbase-site.xml 中参数 hbase.cluster.distributed 的配置值，表示是否为集群模式，接下文附 1</span>
distMode=`$bin/hbase --config &quot;$HBASE_CONF_DIR&quot; org.apache.hadoop.hbase.util.HBaseConfTool hbase.cluster.distributed | head -n 1`
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">当 distMode 为 <span class="hljs-literal">false</span> 时，启动单机测试版，此时 HMaster 和 HRegionServer 以及内嵌的 MiniZooKeeperCluster 均在同一个 JVM 里启动，接下文附 2</span>
if [ &quot;$distMode&quot; == &#x27;false&#x27; ]
then
  &quot;$bin&quot;/hbase-daemon.sh --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; $commandToRun master
<span class="hljs-meta prompt_"># </span><span class="language-bash">当该值为 <span class="hljs-literal">true</span> 时，启动 HBase 集群，接下文附 2。分别启动 Zookeeper、HMaster 和 HRegionServer，其中 Zookeeper 的启动情况分两种，一种是 HBase 管理的，一种是独立部署的，取决于是否在 hbase-env.sh 中配置 HBASE_MANAGES_ZK 参数，为 <span class="hljs-literal">true</span> 时由 HBase 管理。</span>
else
  &quot;$bin&quot;/hbase-daemons.sh --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; $commandToRun zookeeper
  &quot;$bin&quot;/hbase-daemon.sh --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; $commandToRun master
  &quot;$bin&quot;/hbase-daemons.sh --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; \
    --hosts &quot;$&#123;HBASE_REGIONSERVERS&#125;&quot; $commandToRun regionserver
  &quot;$bin&quot;/hbase-daemons.sh --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; \
    --hosts &quot;$&#123;HBASE_BACKUP_MASTERS&#125;&quot; $commandToRun master-backup
fi</code></pre></div><h4 id="附-1"><a href="#附-1" class="headerlink" title="附 1"></a>附 1</h4><p>调用 HBaseConfTool 及相关的 HBaseConfiguration 源码部分，可以清楚地看到读取了配置文件 hbase-default.xml 和 hbase-site.xml，通过脚本传入的 key 来获取相应的 value</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HBaseConfTool</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;
        <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">1</span>) &#123;
          System.err.println(<span class="hljs-string">&quot;Usage: HBaseConfTool &lt;CONFIGURATION_KEY&gt;&quot;</span>);
          System.exit(<span class="hljs-number">1</span>);
          <span class="hljs-keyword">return</span>;
        &#125;
    
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> HBaseConfiguration.create();
        System.out.println(conf.get(args[<span class="hljs-number">0</span>]));
      &#125;
&#125;

---

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HBaseConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Configuration</span> &#123;
  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Configuration <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;
        conf.setClassLoader(HBaseConfiguration.class.getClassLoader());
        <span class="hljs-keyword">return</span> addHbaseResources(conf);
      &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Configuration <span class="hljs-title function_">addHbaseResources</span><span class="hljs-params">(Configuration conf)</span> &#123;
        conf.addResource(<span class="hljs-string">&quot;hbase-default.xml&quot;</span>);
        conf.addResource(<span class="hljs-string">&quot;hbase-site.xml&quot;</span>);
    
        checkDefaultsVersion(conf);
        <span class="hljs-keyword">return</span> conf;
      &#125;
&#125;</code></pre></div><h4 id="附-2"><a href="#附-2" class="headerlink" title="附 2"></a>附 2</h4><p>由 HMaster 接受脚本传入的参数，调用 ServerCommandLine 中的 doMain 方法解析后再通过 HMasterCommandLine 进行启动，单机版和集群版仅仅是在 HMasterCommandLine 中的 run 方法中判断后走了不同的逻辑。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HMaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HRegionServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MasterServices</span> &#123;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> &#123;
        LOG.info(<span class="hljs-string">&quot;STARTING service &quot;</span> + HMaster.class.getSimpleName());
        VersionInfo.logVersion();
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HMasterCommandLine</span>(HMaster.class).doMain(args);
      &#125;
&#125;

---

<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerCommandLine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Configured</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Tool</span> &#123;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doMain</span><span class="hljs-params">(String args[])</span> &#123;
        <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-comment">// 加载 HBase 的配置文件，并调用 ToolRunner 类</span>
          <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> ToolRunner.run(HBaseConfiguration.create(), <span class="hljs-built_in">this</span>, args);
          <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;
            System.exit(ret);
          &#125;
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
          LOG.error(<span class="hljs-string">&quot;Failed to run&quot;</span>, e);
          System.exit(-<span class="hljs-number">1</span>);
        &#125;
      &#125;
&#125;

---

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolRunner</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Configuration conf, Tool tool, String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        ……        
        <span class="hljs-comment">// 调用 HMasterCommandLine 的 run 方法</span>
        <span class="hljs-keyword">return</span> tool.run(toolArgs);
    &#125;
&#125;

---

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HMasterCommandLine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServerCommandLine</span> &#123;
    
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-comment">// 添加默认参数</span>
        ……
    
        CommandLine cmd;
        <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-comment">// 解析参数，失败则最终会调用 HMasterCommandLine 的 getUsage 方法返回操作指示，此处将 start 作为 args 加入到 cmd 中</span>
          cmd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GnuParser</span>().parse(opt, args);
        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;
          LOG.error(<span class="hljs-string">&quot;Could not parse: &quot;</span>, e);
          usage(<span class="hljs-literal">null</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125;
    
        <span class="hljs-comment">// 配置参数</span>
        ……
                
        <span class="hljs-comment">// 最终解析完成的剩下的参数，此处为 start</span>
        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
        List&lt;String&gt; remainingArgs = cmd.getArgList();
        <span class="hljs-keyword">if</span> (remainingArgs.size() != <span class="hljs-number">1</span>) &#123;
          usage(<span class="hljs-literal">null</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125;
    
        <span class="hljs-type">String</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> remainingArgs.get(<span class="hljs-number">0</span>);
        
        <span class="hljs-comment">// 根据接收到的 command 调用相应方法</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;start&quot;</span>.equals(command)) &#123;
          <span class="hljs-keyword">return</span> startMaster();
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;stop&quot;</span>.equals(command)) &#123;
          <span class="hljs-keyword">return</span> stopMaster();
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;clear&quot;</span>.equals(command)) &#123;
          <span class="hljs-keyword">return</span> (ZNodeClearer.clear(getConf()) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
          usage(<span class="hljs-string">&quot;Invalid command: &quot;</span> + command);
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125;
      &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">startMaster</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// 获取配置参数</span>
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> getConf();
        <span class="hljs-comment">// TraceUtil 是个包装类，以一种简化的方式提供了访问 htrace 4+ 的函数，Apache HTrace 是 Cloudera 开源出来的一个分布式系统跟踪框架，支持HDFS和HBase等系统，为应用提供请求跟踪和性能分析</span>
        TraceUtil.initTracer(conf);
    
        <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-comment">// 这里从配置文件中识别出当前是单机模式还是集群模式，单机模式下指的是 LocalHBaseCluster 实例，会在同一个 JVM 里启动 Master 和 RegionServer</span>
          <span class="hljs-keyword">if</span> (LocalHBaseCluster.isLocal(conf)) &#123;
            DefaultMetricsSystem.setMiniClusterMode(<span class="hljs-literal">true</span>);
            <span class="hljs-comment">// 单机模式下启动 MiniZooKeeperCluster 作为 Zookeeper 服务，该类中的许多代码都是从 Zookeeper 的测试代码中剥离出来的</span>
            <span class="hljs-keyword">final</span> <span class="hljs-type">MiniZooKeeperCluster</span> <span class="hljs-variable">zooKeeperCluster</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniZooKeeperCluster</span>(conf);
            <span class="hljs-comment">// 从配置文件获取 hbase.zookeeper.property.dataDir 配置的参数作为 Zookeeper 数据目录</span>
            <span class="hljs-type">File</span> <span class="hljs-variable">zkDataPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(conf.get(HConstants.ZOOKEEPER_DATA_DIR));
    
            <span class="hljs-comment">// find out the default client port</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">zkClientPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    
            <span class="hljs-comment">// 从 hbase.zookeeper.quorum 参数解析并获取 Zookeeper 配置的端口号</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">zkserver</span> <span class="hljs-operator">=</span> conf.get(HConstants.ZOOKEEPER_QUORUM);
            <span class="hljs-keyword">if</span> (zkserver != <span class="hljs-literal">null</span>) &#123;
              String[] zkservers = zkserver.split(<span class="hljs-string">&quot;,&quot;</span>);
              <span class="hljs-comment">// 单机模式仅支持一个 Zookeeper 服务</span>
              <span class="hljs-keyword">if</span> (zkservers.length &gt; <span class="hljs-number">1</span>) &#123;
                <span class="hljs-comment">// In local mode deployment, we have the master + a region server and zookeeper server</span>
                <span class="hljs-comment">// started in the same process. Therefore, we only support one zookeeper server.</span>
                <span class="hljs-type">String</span> <span class="hljs-variable">errorMsg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Could not start ZK with &quot;</span> + zkservers.length +
                    <span class="hljs-string">&quot; ZK servers in local mode deployment. Aborting as clients (e.g. shell) will not &quot;</span>
                    + <span class="hljs-string">&quot;be able to find this ZK quorum.&quot;</span>;
                  System.err.println(errorMsg);
                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(errorMsg);
              &#125;
    
              String[] parts = zkservers[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;:&quot;</span>);
    
              <span class="hljs-keyword">if</span> (parts.length == <span class="hljs-number">2</span>) &#123;
                <span class="hljs-comment">// the second part is the client port</span>
                zkClientPort = Integer.parseInt(parts [<span class="hljs-number">1</span>]);
              &#125;
            &#125;
            <span class="hljs-comment">// If the client port could not be find in server quorum conf, try another conf</span>
            <span class="hljs-keyword">if</span> (zkClientPort == <span class="hljs-number">0</span>) &#123;
              zkClientPort = conf.getInt(HConstants.ZOOKEEPER_CLIENT_PORT, <span class="hljs-number">0</span>);
              <span class="hljs-comment">// The client port has to be set by now; if not, throw exception.</span>
              <span class="hljs-keyword">if</span> (zkClientPort == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;No config value for &quot;</span> + HConstants.ZOOKEEPER_CLIENT_PORT);
              &#125;
            &#125;
            zooKeeperCluster.setDefaultClientPort(zkClientPort);
            <span class="hljs-comment">// set the ZK tick time if specified</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">zkTickTime</span> <span class="hljs-operator">=</span> conf.getInt(HConstants.ZOOKEEPER_TICK_TIME, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (zkTickTime &gt; <span class="hljs-number">0</span>) &#123;
              zooKeeperCluster.setTickTime(zkTickTime);
            &#125;
    
            <span class="hljs-comment">// 如果启用了安全认证，需要配置 Zookeeper 的 keytab 文件和 principal 等</span>
            <span class="hljs-comment">// login the zookeeper server principal (if using security)</span>
            ZKUtil.loginServer(conf, HConstants.ZK_SERVER_KEYTAB_FILE,
              HConstants.ZK_SERVER_KERBEROS_PRINCIPAL, <span class="hljs-literal">null</span>);
            <span class="hljs-type">int</span> <span class="hljs-variable">localZKClusterSessionTimeout</span> <span class="hljs-operator">=</span>
              conf.getInt(HConstants.ZK_SESSION_TIMEOUT + <span class="hljs-string">&quot;.localHBaseCluster&quot;</span>, <span class="hljs-number">10</span>*<span class="hljs-number">1000</span>);
            conf.setInt(HConstants.ZK_SESSION_TIMEOUT, localZKClusterSessionTimeout);
            LOG.info(<span class="hljs-string">&quot;Starting a zookeeper cluster&quot;</span>);
            
            <span class="hljs-comment">// 启动 Zookeeper 服务</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">clientPort</span> <span class="hljs-operator">=</span> zooKeeperCluster.startup(zkDataPath);
            <span class="hljs-comment">// Zookeeper 启动失败会输出相应信息</span>
            <span class="hljs-keyword">if</span> (clientPort != zkClientPort) &#123;
              <span class="hljs-type">String</span> <span class="hljs-variable">errorMsg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Could not start ZK at requested port of &quot;</span> +
                zkClientPort + <span class="hljs-string">&quot;.  ZK was started at port: &quot;</span> + clientPort +
                <span class="hljs-string">&quot;.  Aborting as clients (e.g. shell) will not be able to find &quot;</span> +
                <span class="hljs-string">&quot;this ZK quorum.&quot;</span>;
              System.err.println(errorMsg);
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(errorMsg);
            &#125;
            <span class="hljs-comment">// 启动成功则设置 HBase 有关 Zookeeper 的参数</span>
            conf.set(HConstants.ZOOKEEPER_CLIENT_PORT, Integer.toString(clientPort));
    
            <span class="hljs-comment">// Need to have the zk cluster shutdown when master is shutdown.</span>
            <span class="hljs-comment">// Run a subclass that does the zk cluster shutdown on its way out.</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">mastersCount</span> <span class="hljs-operator">=</span> conf.getInt(<span class="hljs-string">&quot;hbase.masters&quot;</span>, <span class="hljs-number">1</span>);
            <span class="hljs-type">int</span> <span class="hljs-variable">regionServersCount</span> <span class="hljs-operator">=</span> conf.getInt(<span class="hljs-string">&quot;hbase.regionservers&quot;</span>, <span class="hljs-number">1</span>);
            <span class="hljs-comment">// Set start timeout to 5 minutes for cmd line start operations</span>
            conf.setIfUnset(<span class="hljs-string">&quot;hbase.master.start.timeout.localHBaseCluster&quot;</span>, <span class="hljs-string">&quot;300000&quot;</span>);
            LOG.info(<span class="hljs-string">&quot;Starting up instance of localHBaseCluster; master=&quot;</span> + mastersCount +
              <span class="hljs-string">&quot;, regionserversCount=&quot;</span> + regionServersCount);
            
            <span class="hljs-comment">// LocalHMaster 继承自 HMaster，和 HRegionServer 同时启动，在停止的同时也停止 Zookeeper 服务</span>
            <span class="hljs-type">LocalHBaseCluster</span> <span class="hljs-variable">cluster</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalHBaseCluster</span>(conf, mastersCount, regionServersCount,
              LocalHMaster.class, HRegionServer.class);
            
            <span class="hljs-comment">// 将运行的 zooKeeperCluster 置于 LocalHMaster 中，以便在 LocalHMaster 停止的时候停止 Zookeeper 服务</span>
            ((LocalHMaster)cluster.getMaster(<span class="hljs-number">0</span>)).setZKCluster(zooKeeperCluster);
            <span class="hljs-comment">// 调用 LocalHBaseCluster 的 startup 方法启动</span>
            cluster.startup();
            waitOnMasterThreads(cluster);
          &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 启动集群模式</span>
            <span class="hljs-comment">// 记录有关当前正在运行的JVM进程的信息，包括环境变量，可以通过配置 hbase.envvars.logging.disabled 为 true 禁用</span>
            logProcessInfo(getConf());
            <span class="hljs-comment">// 通过反射 HMaster 的构造方法对其进行实例化</span>
            <span class="hljs-type">HMaster</span> <span class="hljs-variable">master</span> <span class="hljs-operator">=</span> HMaster.constructMaster(masterClass, conf);
            <span class="hljs-comment">// 如果此时请求关闭 HMaster 则不会启动</span>
            <span class="hljs-keyword">if</span> (master.isStopped()) &#123;
              LOG.info(<span class="hljs-string">&quot;Won&#x27;t bring the Master up as a shutdown is requested&quot;</span>);
              <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            &#125;
            <span class="hljs-comment">// 启动 HMaster，调用 HMaster 的 run 方法进行处理</span>
            master.start();
            <span class="hljs-comment">// 等待 HMaster 启动成功</span>
            master.join();
            <span class="hljs-comment">// 异常信息则输出错误信息</span>
            <span class="hljs-keyword">if</span>(master.isAborted())
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;HMaster Aborted&quot;</span>);
          &#125;
        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
          LOG.error(<span class="hljs-string">&quot;Master exiting&quot;</span>, t);
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      
    <span class="hljs-comment">// 由 HMasterCommandLine 在 startMaster 方法中启动单机模式的 HBase 时调用  </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitOnMasterThreads</span><span class="hljs-params">(LocalHBaseCluster cluster)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;
        List&lt;JVMClusterUtil.MasterThread&gt; masters = cluster.getMasters();
        List&lt;JVMClusterUtil.RegionServerThread&gt; regionservers = cluster.getRegionServers();
    
        <span class="hljs-keyword">if</span> (masters != <span class="hljs-literal">null</span>) &#123;
          <span class="hljs-keyword">for</span> (JVMClusterUtil.MasterThread t : masters) &#123;
            <span class="hljs-comment">// 先等待 MasterThread 启动完成再启动 RegionServerThread，如果出现异常则关闭 RegionServer 并输出错误信息</span>
            t.join();
            <span class="hljs-keyword">if</span>(t.getMaster().isAborted()) &#123;
              closeAllRegionServerThreads(regionservers);
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;HMaster Aborted&quot;</span>);
            &#125;
          &#125;
        &#125;
      &#125;
&#125;

---

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalHBaseCluster</span> &#123;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalHBaseCluster</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Configuration conf, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> noMasters,</span>
<span class="hljs-params">        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> noRegionServers, <span class="hljs-keyword">final</span> Class&lt;? extends HMaster&gt; masterClass,</span>
<span class="hljs-params">        <span class="hljs-keyword">final</span> Class&lt;? extends HRegionServer&gt; regionServerClass)</span>
      <span class="hljs-keyword">throws</span> IOException &#123;
        <span class="hljs-built_in">this</span>.conf = conf;
    
        <span class="hljs-comment">// 获取及配置 HBase 相关参数</span>
        ……
        
        <span class="hljs-comment">// 设置 masterClass，此处即为传入的 LocalHMaster</span>
        <span class="hljs-built_in">this</span>.masterClass = (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HMaster</span>&gt;)
          conf.getClass(HConstants.MASTER_IMPL, masterClass);
          
        <span class="hljs-comment">// 最终调用至 JVMClusterUtil 工具类的 createMasterThread 方法，通过反射调用继承自 HMaster 的子类构造方法进行实例化，得到 MasterThread</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; noMasters; i++) &#123;
          addMaster(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(conf), i);
        &#125;
        
        <span class="hljs-comment">// 设置 regionServerClass，此处即为传入的 HRegionServer</span>
        <span class="hljs-built_in">this</span>.regionServerClass =
          (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HRegionServer</span>&gt;)conf.getClass(HConstants.REGION_SERVER_IMPL,
           regionServerClass);
    
        <span class="hljs-comment">// 最终调用至 JVMClusterUtil 工具类的 createRegionServerThread 方法，通过反射调用继承自 HRegionServer 的子类构造方法进行实例化，得到 RegionServerThread</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; noRegionServers; i++) &#123;
          addRegionServer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(conf), i);
        &#125;
      &#125;
      
    <span class="hljs-comment">// 启动前面实例化好的 masterThreads 和 regionThreads，等待启动完成，至此单机模式下的 HMaster 和 HRegionServer 均已启动，可以正常提供服务</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;
        JVMClusterUtil.startup(<span class="hljs-built_in">this</span>.masterThreads, <span class="hljs-built_in">this</span>.regionThreads);
    &#125;
&#125;

---

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalHMaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HMaster</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-type">MiniZooKeeperCluster</span> <span class="hljs-variable">zkcluster</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalHMaster</span><span class="hljs-params">(Configuration conf)</span>
    <span class="hljs-keyword">throws</span> IOException, KeeperException, InterruptedException &#123;
      <span class="hljs-built_in">super</span>(conf);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
      <span class="hljs-comment">// 调用父类 HMaster 的 run 方法</span>
      <span class="hljs-built_in">super</span>.run();
      <span class="hljs-comment">// 调用 MiniZooKeeperCluster 的 shutdown 方法，停止单机模式下的 Zookeeper 服务</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.zkcluster != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-built_in">this</span>.zkcluster.shutdown();
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
          e.printStackTrace();
        &#125;
      &#125;
    &#125;

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZKCluster</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MiniZooKeeperCluster zkcluster)</span> &#123;
      <span class="hljs-built_in">this</span>.zkcluster = zkcluster;
    &#125;
  &#125;</code></pre></div><h3 id="hbase-config-sh"><a href="#hbase-config-sh" class="headerlink" title="hbase-config.sh"></a>hbase-config.sh</h3><p>用于获取配置参数的脚本，会去加载 hbase-env.sh 中设置的环境变量。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前路径</span>
this=&quot;$&#123;BASH_SOURCE-$0&#125;&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">解析 <span class="hljs-variable">$&#123;BASH_SOURCE-$0&#125;</span> 有可能是 softlink 的问题</span>
while [ -h &quot;$this&quot; ]; do
  ls=`ls -ld &quot;$this&quot;`
  link=`expr &quot;$ls&quot; : &#x27;.*-&gt; \(.*\)$&#x27;`
  if expr &quot;$link&quot; : &#x27;.*/.*&#x27; &gt; /dev/null; then
    this=&quot;$link&quot;
  else
    this=`dirname &quot;$this&quot;`/&quot;$link&quot;
  fi
done
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">convert relative path to absolute path</span>
bin=`dirname &quot;$this&quot;`
script=`basename &quot;$this&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`
this=&quot;$bin/$script&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">将 HBASE_HOME 设置为 HBase 安装的根目录</span>
if [ -z &quot;$HBASE_HOME&quot; ]; then
  export HBASE_HOME=`dirname &quot;$this&quot;`/..
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">检查是否有可选参数传入，接受到则进行相应的参数设置</span>
……
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">以下项为参数设置</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">Allow alternate hbase conf <span class="hljs-built_in">dir</span> location.</span>
HBASE_CONF_DIR=&quot;$&#123;HBASE_CONF_DIR:-$HBASE_HOME/conf&#125;&quot;
<span class="hljs-meta prompt_"># </span><span class="language-bash">List of hbase regions servers.</span>
HBASE_REGIONSERVERS=&quot;$&#123;HBASE_REGIONSERVERS:-$HBASE_CONF_DIR/regionservers&#125;&quot;
<span class="hljs-meta prompt_"># </span><span class="language-bash">List of hbase secondary masters.</span>
HBASE_BACKUP_MASTERS=&quot;$&#123;HBASE_BACKUP_MASTERS:-$HBASE_CONF_DIR/backup-masters&#125;&quot;
if [ -n &quot;$HBASE_JMX_BASE&quot; ] &amp;&amp; [ -z &quot;$HBASE_JMX_OPTS&quot; ]; then
  HBASE_JMX_OPTS=&quot;$HBASE_JMX_BASE&quot;
fi

……
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载 hbase-env.sh</span>
if [ -z &quot;$HBASE_ENV_INIT&quot; ] &amp;&amp; [ -f &quot;$&#123;HBASE_CONF_DIR&#125;/hbase-env.sh&quot; ]; then
  . &quot;$&#123;HBASE_CONF_DIR&#125;/hbase-env.sh&quot;
  export HBASE_ENV_INIT=&quot;true&quot;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">检测 HBASE_REGIONSERVER_MLOCK 是否设置为 <span class="hljs-literal">true</span>，主要是判断系统是否使用了 mlock 来锁住内存，防止这段内存被操作系统放到 swap 空间，即使该程序已经有一段时间没有访问这段空间</span>
if [ &quot;$HBASE_REGIONSERVER_MLOCK&quot; = &quot;true&quot; ]; then
  MLOCK_AGENT=&quot;$HBASE_HOME/lib/native/libmlockall_agent.so&quot;
  if [ ! -f &quot;$MLOCK_AGENT&quot; ]; then
    cat 1&gt;&amp;2 &lt;&lt;EOF
Unable to find mlockall_agent, hbase must be compiled with -Pnative
EOF
    exit 1
  fi
  // 配置 HBASE_REGIONSERVER_UID
  if [ -z &quot;$HBASE_REGIONSERVER_UID&quot; ] || [ &quot;$HBASE_REGIONSERVER_UID&quot; == &quot;$USER&quot; ]; then
      HBASE_REGIONSERVER_OPTS=&quot;$HBASE_REGIONSERVER_OPTS -agentpath:$MLOCK_AGENT&quot;
  else
      HBASE_REGIONSERVER_OPTS=&quot;$HBASE_REGIONSERVER_OPTS -agentpath:$MLOCK_AGENT=user=$HBASE_REGIONSERVER_UID&quot;
  fi
fi

……
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">检查是否配置了 jdk，HBase-2.2.4 至少需要 1.8 以上的 JDK 版本，未配置则退出</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">Now having JAVA_HOME defined is required</span> 
if [ -z &quot;$JAVA_HOME&quot; ]; then
    cat 1&gt;&amp;2 &lt;&lt;EOF
……
fi</code></pre></div><h3 id="hbase-daemons-sh"><a href="#hbase-daemons-sh" class="headerlink" title="hbase-daemons.sh"></a>hbase-daemons.sh</h3><p>根据要启动的进程，生成好远程执行命令 remote_cmd 并调用其他脚本执行。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">脚本用法</span>
usage=&quot;Usage: hbase-daemons.sh [--config &lt;hbase-confdir&gt;] [--autostart-window-size &lt;window size in hours&gt;]\
      [--autostart-window-retry-limit &lt;retry count limit for autostart&gt;] \
      [--hosts regionserversfile] [autostart|autorestart|restart|start|stop] command args...&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有指定参数，输出 usage</span>
if [ $# -le 1 ]; then
  echo $usage
  exit 1
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前路径</span>
bin=`dirname &quot;$&#123;BASH_SOURCE-$0&#125;&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">默认的自动启动参数相关配置，一般前面脚本都是传递诸如 start 参数过来，可以忽略</span>
AUTOSTART_WINDOW_SIZE=0
AUTOSTART_WINDOW_RETRY_LIMIT=0
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载 hbase-config.sh 脚本</span>
. $bin/hbase-config.sh

……
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">调用 hbase-daemon.sh 并向其传递参数</span>
remote_cmd=&quot;$bin/hbase-daemon.sh --config $&#123;HBASE_CONF_DIR&#125; $&#123;autostart_args&#125; $@&quot;
<span class="hljs-meta prompt_"># </span><span class="language-bash">将 <span class="hljs-variable">$remote_cmd</span> 作为参数继续包装到 args 中</span>
args=&quot;--hosts $&#123;HBASE_REGIONSERVERS&#125; --config $&#123;HBASE_CONF_DIR&#125; $remote_cmd&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">接受到的第二个参数的值，例如 start-hbase.sh 集群模式下传递了 zookeeper、regionserver 等，基于该参数分别调用相应的脚本执行，执行后退出</span>
command=$2
case $command in
  (zookeeper)
    exec &quot;$bin/zookeepers.sh&quot; $args
    ;;
  (master-backup)
    exec &quot;$bin/master-backup.sh&quot; $args
    ;;
  (*)
    exec &quot;$bin/regionservers.sh&quot; $args
    ;;
esac</code></pre></div><h3 id="hbase-daemon-sh"><a href="#hbase-daemon-sh" class="headerlink" title="hbase-daemon.sh"></a>hbase-daemon.sh</h3><p>这个脚本很重要，前面的脚本都是做一些准备工作，它负责启动前的检查清理、日志滚动以及进程的启动等等。支持 7 种方式：start、autostart、autorestart、foreground_start、internal_autostart、stop、restart，其他参数则输出操作用法。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将 Hadoop hbase 命令作为守护程序执行</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">环境变量</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">配置文件目录，默认是 <span class="hljs-variable">$&#123;HBASE_HOME&#125;</span>/conf</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_CONF_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">日志存储目录，默认情况下为 <span class="hljs-built_in">pwd</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_LOG_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">进程号存放目录，默认是 /tmp</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_PID_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">代表当前 hadoop 实例的字符串，默认是当前点用户 <span class="hljs-variable">$USER</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_IDENT_STRING</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">守护程序的调度优先级，默认是 0</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_NICENESS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">在停止服务此时间之后，服务还未停止，将对其执行 <span class="hljs-built_in">kill</span> -9 命令，默认 1200（单位是 s）</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_STOP_TIMEOUT</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">仿照了 <span class="hljs-variable">$HADOOP_HOME</span>/bin/hadoop-daemon.sh</span>
usage=&quot;Usage: hbase-daemon.sh [--config &lt;conf-dir&gt;]\
 [--autostart-window-size &lt;window size in hours&gt;]\
 [--autostart-window-retry-limit &lt;retry count limit for autostart&gt;]\
 (start|stop|restart|autostart|autorestart|foreground_start) &lt;hbase-command&gt; \
 &lt;args...&gt;&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有指定参数，输出 usage</span>
if [ $# -le 1 ]; then
  echo $usage
  exit 1
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">默认的自动启动配置参数</span>
AUTOSTART_WINDOW_SIZE=0
AUTOSTART_WINDOW_RETRY_LIMIT=0
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前路径</span>
bin=`dirname &quot;$&#123;BASH_SOURCE-$0&#125;&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载 hbase-config.sh 以及 hbase-common.sh</span>
. &quot;$bin&quot;/hbase-config.sh
. &quot;$bin&quot;/hbase-common.sh
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取传递的参数，即 start 或 stop</span>
startStop=$1
<span class="hljs-meta prompt_"># </span><span class="language-bash">命令左移，<span class="hljs-built_in">shift</span> 命令每执行一次，变量的个数(<span class="hljs-variable">$#</span>)减一，而变量值提前一位</span>
shift

command=$1
shift
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">日志滚动</span>
hbase_rotate_log ()
&#123;
    log=$1;
    num=5;
    if [ -n &quot;$2&quot; ]; then
    num=$2
    fi
    # 检查是否存在日志文件，若存在则进行日志滚动
    if [ -f &quot;$log&quot; ]; then # rotate logs
    while [ $num -gt 1 ]; do
        prev=`expr $num - 1`
        [ -f &quot;$log.$prev&quot; ] &amp;&amp; mv -f &quot;$log.$prev&quot; &quot;$log.$num&quot;
        num=$prev
    done
    # 修改日志文件名
    mv -f &quot;$log&quot; &quot;$log.$num&quot;;
    fi
&#125;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">当运行遇到问题时进行清理，在 foreground_start 方式中，接收到 SIGHUP（终端线路挂断） SIGINT（中断进程） SIGTERM（软件终止信号） EXIT（退出）等信号时，</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">使用 <span class="hljs-built_in">trap</span> 命令对要处理的信号名采取相应的行动，即 <span class="hljs-built_in">kill</span> 掉正在运行的进程，并通知 Zookeeper 删除节点</span>
cleanAfterRun() &#123;
  if [ -f $&#123;HBASE_PID&#125; ]; then
    # If the process is still running time to tear it down.
    kill -9 `cat $&#123;HBASE_PID&#125;` &gt; /dev/null 2&gt;&amp;1
    rm -f $&#123;HBASE_PID&#125; &gt; /dev/null 2&gt;&amp;1
  fi

  if [ -f $&#123;HBASE_ZNODE_FILE&#125; ]; then
    if [ &quot;$command&quot; = &quot;master&quot; ]; then
      HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_MASTER_OPTS&quot; $bin/hbase master clear &gt; /dev/null 2&gt;&amp;1
    else
      # call ZK to delete the node
      ZNODE=`cat $&#123;HBASE_ZNODE_FILE&#125;`
      HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_REGIONSERVER_OPTS&quot; $bin/hbase zkcli delete $&#123;ZNODE&#125; &gt; /dev/null 2&gt;&amp;1
    fi
    rm $&#123;HBASE_ZNODE_FILE&#125;
  fi
&#125;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">启动之间先检查进程是否存在，存在则输出警告信息</span>
check_before_start()&#123;
    #ckeck if the process is not running
    mkdir -p &quot;$HBASE_PID_DIR&quot;
    if [ -f $HBASE_PID ]; then
      # kill -0 pid 不发送任何信号，但是系统会进行错误检查，检查一个进程是否存在，存在返回 0；不存在返回 1
      if kill -0 `cat $HBASE_PID` &gt; /dev/null 2&gt;&amp;1; then
        echo $command running as process `cat $HBASE_PID`.  Stop it first.
        exit 1
      fi
    fi
&#125;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">等待命令执行完成，超过 HBASE_SLAVE_TIMEOUT 即 300 之后则调用 <span class="hljs-built_in">kill</span> -9 杀掉服务并输出警告信息</span>
wait_until_done ()
&#123;
    p=$1
    cnt=$&#123;HBASE_SLAVE_TIMEOUT:-300&#125;
    origcnt=$cnt
    # 进程仍在运行，睡眠 1s 后重新判断，直到超过指定次数（时间）调用 kill -9 $pid
    while kill -0 $p &gt; /dev/null 2&gt;&amp;1; do
      if [ $cnt -gt 1 ]; then
        cnt=`expr $cnt - 1`
        sleep 1
      else
        echo &quot;Process did not complete after $origcnt seconds, killing.&quot;
        kill -9 $p
        exit 1
      fi
    done
    return 0
&#125;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取日志目录</span>
if [ &quot;$HBASE_LOG_DIR&quot; = &quot;&quot; ]; then
  export HBASE_LOG_DIR=&quot;$HBASE_HOME/logs&quot;
fi
mkdir -p &quot;$HBASE_LOG_DIR&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有配置 HBASE_PID_DIR 目录，则默认为 /tmp</span>
if [ &quot;$HBASE_PID_DIR&quot; = &quot;&quot; ]; then
  HBASE_PID_DIR=/tmp
fi

if [ &quot;$HBASE_IDENT_STRING&quot; = &quot;&quot; ]; then
  export HBASE_IDENT_STRING=&quot;$USER&quot;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">配置 JAVA_HOME</span>
if [ &quot;$JAVA_HOME&quot; != &quot;&quot; ]; then
<span class="hljs-meta prompt_">  #</span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;run java in <span class="hljs-variable">$JAVA_HOME</span>&quot;</span></span>
  JAVA_HOME=$JAVA_HOME
fi
if [ &quot;$JAVA_HOME&quot; = &quot;&quot; ]; then
  echo &quot;Error: JAVA_HOME is not set.&quot;
  exit 1
fi

JAVA=$JAVA_HOME/bin/java
<span class="hljs-meta prompt_"># </span><span class="language-bash">日志前缀，如：hbase-root-master-node1</span>
export HBASE_LOG_PREFIX=hbase-$HBASE_IDENT_STRING-$command-$HOSTNAME
export HBASE_LOGFILE=$HBASE_LOG_PREFIX.log
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果未配置 HBASE_ROOT_LOGGER 参数，则设置默认的日志级别</span>
if [ -z &quot;$&#123;HBASE_ROOT_LOGGER&#125;&quot; ]; then
export HBASE_ROOT_LOGGER=$&#123;HBASE_ROOT_LOGGER:-&quot;INFO,RFA&quot;&#125;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果未配置 HBASE_SECURITY_LOGGER 参数，则设置默认的安全日志级别</span>
if [ -z &quot;$&#123;HBASE_SECURITY_LOGGER&#125;&quot; ]; then
export HBASE_SECURITY_LOGGER=$&#123;HBASE_SECURITY_LOGGER:-&quot;INFO,RFAS&quot;&#125;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">out 日志，即 System.out 输出信息</span>
HBASE_LOGOUT=$&#123;HBASE_LOGOUT:-&quot;$HBASE_LOG_DIR/$HBASE_LOG_PREFIX.out&quot;&#125;
HBASE_LOGGC=$&#123;HBASE_LOGGC:-&quot;$HBASE_LOG_DIR/$HBASE_LOG_PREFIX.gc&quot;&#125;
HBASE_LOGLOG=$&#123;HBASE_LOGLOG:-&quot;$&#123;HBASE_LOG_DIR&#125;/$&#123;HBASE_LOGFILE&#125;&quot;&#125;
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBase 相关服务进程</span>
HBASE_PID=$HBASE_PID_DIR/hbase-$HBASE_IDENT_STRING-$command.pid
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBase 的 znode 文件</span>
export HBASE_ZNODE_FILE=$HBASE_PID_DIR/hbase-$HBASE_IDENT_STRING-$command.znode
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBase 的 autostart 文件</span>
export HBASE_AUTOSTART_FILE=$HBASE_PID_DIR/hbase-$HBASE_IDENT_STRING-$command.autostart
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果配置了 SERVER_GC_OPTS、CLIENT_GC_OPTS 参数，则设置对应变量</span>
if [ -n &quot;$SERVER_GC_OPTS&quot; ]; then
  export SERVER_GC_OPTS=$&#123;SERVER_GC_OPTS/&quot;-Xloggc:&lt;FILE-PATH&gt;&quot;/&quot;-Xloggc:$&#123;HBASE_LOGGC&#125;&quot;&#125;
fi
if [ -n &quot;$CLIENT_GC_OPTS&quot; ]; then
  export CLIENT_GC_OPTS=$&#123;CLIENT_GC_OPTS/&quot;-Xloggc:&lt;FILE-PATH&gt;&quot;/&quot;-Xloggc:$&#123;HBASE_LOGGC&#125;&quot;&#125;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">设置默认的程度调度优先级为 0</span>
if [ &quot;$HBASE_NICENESS&quot; = &quot;&quot; ]; then
    export HBASE_NICENESS=0
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前路径</span>
thiscmd=&quot;$bin/$(basename $&#123;BASH_SOURCE-$0&#125;)&quot;
args=$@

case $startStop in

(start)
    check_before_start
    hbase_rotate_log $HBASE_LOGOUT
    hbase_rotate_log $HBASE_LOGGC
    # 输出启动的程序，以及日志输出目录，接着调用 foreground_start 
    echo running $command, logging to $HBASE_LOGOUT
    $thiscmd --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; \
        foreground_start $command $args &lt; /dev/null &gt; $&#123;HBASE_LOGOUT&#125; 2&gt;&amp;1  &amp;
    # 使正在运行的作业忽略 HUP 信号，避免当用户注销（logout）或者网络断开时，终端会收到 Linux HUP（hangup）信号从而关闭其所有子进程
    disown -h -r
    sleep 1; head &quot;$&#123;HBASE_LOGOUT&#125;&quot;
  ;;

(autostart)
    check_before_start
    hbase_rotate_log $HBASE_LOGOUT
    hbase_rotate_log $HBASE_LOGGC
    echo running $command, logging to $HBASE_LOGOUT
    # 使用 nohup 挂起并执行自动启动程序，调用 internal_autostart 继续执行
    nohup $thiscmd --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; --autostart-window-size $&#123;AUTOSTART_WINDOW_SIZE&#125; --autostart-window-retry-limit $&#123;AUTOSTART_WINDOW_RETRY_LIMIT&#125; \
        internal_autostart $command $args &lt; /dev/null &gt; $&#123;HBASE_LOGOUT&#125; 2&gt;&amp;1  &amp;
  ;;

(autorestart)
    echo running $command, logging to $HBASE_LOGOUT
    # 先停止当前服务，并等待所有进程都停止
    $thiscmd --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; stop $command $args &amp;
    wait_until_done $!
    # 等待用户指定的睡眠周期
    sp=$&#123;HBASE_RESTART_SLEEP:-3&#125;
    if [ $sp -gt 0 ]; then
      sleep $sp
    fi

    check_before_start
    hbase_rotate_log $HBASE_LOGOUT
    # 使用 nohup 挂起并执行自动启动程序，调用 internal_autostart 继续执行
    nohup $thiscmd --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; --autostart-window-size $&#123;AUTOSTART_WINDOW_SIZE&#125; --autostart-window-retry-limit $&#123;AUTOSTART_WINDOW_RETRY_LIMIT&#125; \
        internal_autostart $command $args &lt; /dev/null &gt; $&#123;HBASE_LOGOUT&#125; 2&gt;&amp;1  &amp;
  ;;

(foreground_start)
    trap cleanAfterRun SIGHUP SIGINT SIGTERM EXIT
    # 日志不重定向参数，一般都输出到日志中，这部分逻辑主要走 else
    if [ &quot;$HBASE_NO_REDIRECT_LOG&quot; != &quot;&quot; ]; then
        # NO REDIRECT
        echo &quot;`date` Starting $command on `hostname`&quot;
        echo &quot;`ulimit -a`&quot;
        # in case the parent shell gets the kill make sure to trap signals.
        # Only one will get called. Either the trap or the flow will go through.
        nice -n $HBASE_NICENESS &quot;$HBASE_HOME&quot;/bin/hbase \
            --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; \
            $command &quot;$@&quot; start &amp;
    else
        echo &quot;`date` Starting $command on `hostname`&quot; &gt;&gt; $&#123;HBASE_LOGLOG&#125;
        echo &quot;`ulimit -a`&quot; &gt;&gt; &quot;$HBASE_LOGLOG&quot; 2&gt;&amp;1
        # nice 以更改过的优先序来执行程序，调用 $HBASE_HOME/bin/hbase 传递参数继续执行
        nice -n $HBASE_NICENESS &quot;$HBASE_HOME&quot;/bin/hbase \
            --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; \
            $command &quot;$@&quot; start &gt;&gt; $&#123;HBASE_LOGOUT&#125; 2&gt;&amp;1 &amp;
    fi
    # 获取最后一个进程号，将其覆盖写入 $HBASE_PID 文件中，暂停当前进程并释放资源等待前面的线程执行
    hbase_pid=$!
    echo $hbase_pid &gt; $&#123;HBASE_PID&#125;
    wait $hbase_pid
  ;;

(internal_autostart)
    ONE_HOUR_IN_SECS=3600
    # 自动启动的开始日期
    autostartWindowStartDate=`date +%s`
    autostartCount=0
    # 创建自动启动的文件
    touch &quot;$HBASE_AUTOSTART_FILE&quot;

    # 除非被要求停止，否则一直保持启动命令的状态，在崩溃时重新进入循环
    while true
    do
      hbase_rotate_log $HBASE_LOGGC
      if [ -f $HBASE_PID ] &amp;&amp;  kill -0 &quot;$(cat &quot;$HBASE_PID&quot;)&quot; &gt; /dev/null 2&gt;&amp;1 ; then
        wait &quot;$(cat &quot;$HBASE_PID&quot;)&quot;
      else
        # 如果 $HBASE_AUTOSTART_FILE 不存在，说明服务可能不是通过 stop 命令停止的
        if [ ! -f &quot;$HBASE_AUTOSTART_FILE&quot; ]; then
          echo &quot;`date` HBase might be stopped removing the autostart file. Exiting Autostart process&quot; &gt;&gt; $&#123;HBASE_LOGOUT&#125;
          exit 1
        fi

        echo &quot;`date` Autostarting hbase $command service. Attempt no: $(( $autostartCount + 1))&quot; &gt;&gt; $&#123;HBASE_LOGLOG&#125;
        touch &quot;$HBASE_AUTOSTART_FILE&quot;
        $thiscmd --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; foreground_start $command $args
        autostartCount=$(( $autostartCount + 1 ))

        # HBASE-6504 - 仅当输出详细gc时，才采用输出的第一行
        distMode=`$bin/hbase --config &quot;$HBASE_CONF_DIR&quot; org.apache.hadoop.hbase.util.HBaseConfTool hbase.cluster.distributed | head -n 1`

        if [ &quot;$distMode&quot; != &#x27;false&#x27; ]; then
          # 如果集群正在被停止，不再重启
          zparent=`$bin/hbase org.apache.hadoop.hbase.util.HBaseConfTool zookeeper.znode.parent`
          # 创建对应的 znode 并设置服务运行状态
          if [ &quot;$zparent&quot; == &quot;null&quot; ]; then zparent=&quot;/hbase&quot;; fi
          zkrunning=`$bin/hbase org.apache.hadoop.hbase.util.HBaseConfTool zookeeper.znode.state`
          if [ &quot;$zkrunning&quot; == &quot;null&quot; ]; then zkrunning=&quot;running&quot;; fi
          zkFullRunning=$zparent/$zkrunning
          $bin/hbase zkcli stat $zkFullRunning 2&gt;&amp;1 | grep &quot;Node does not exist&quot;  1&gt;/dev/null 2&gt;&amp;1

          # 如果发现上述指令的 grep 匹配到结果，则说明遇到了问题，显示警告信息，处理后退出
          if [ $? -eq 0 ]; then
            echo &quot;`date` hbase znode does not exist. Exiting Autostart process&quot; &gt;&gt; $&#123;HBASE_LOGOUT&#125;
            # 删除 $HBASE_AUTOSTART_FILE 文件
            rm -f &quot;$HBASE_AUTOSTART_FILE&quot;
            exit 1
          fi

          # 如果没有找到 Zookeeper 服务，就不重启并显示警告信息
          $bin/hbase zkcli stat $zkFullRunning 2&gt;&amp;1 | grep Exception | grep ConnectionLoss  1&gt;/dev/null 2&gt;&amp;1
          if [ $? -eq 0 ]; then
            echo &quot;`date` zookeeper not found. Exiting Autostart process&quot; &gt;&gt; $&#123;HBASE_LOGOUT&#125;
            rm -f &quot;$HBASE_AUTOSTART_FILE&quot;
            exit 1
          fi
        fi
      fi

      // 当前日期
      curDate=`date +%s`
      // 是否重新设置自动启动窗口
      autostartWindowReset=false

      # 假如超过了自动启动的窗口大小，就重新设置一下
      if [ $AUTOSTART_WINDOW_SIZE -gt 0 ] &amp;&amp; [ $(( $curDate - $autostartWindowStartDate )) -gt $(( $AUTOSTART_WINDOW_SIZE * $ONE_HOUR_IN_SECS )) ]; then
        echo &quot;Resetting Autorestart window size: $autostartWindowStartDate&quot; &gt;&gt; $&#123;HBASE_LOGOUT&#125;
        autostartWindowStartDate=$curDate
        autostartWindowReset=true
        autostartCount=0
      fi

      # 当重试次数超过了给定的窗口大小限制（窗口大小不是 0），就杀掉程序，处理后退出
      if ! $autostartWindowReset &amp;&amp; [ $AUTOSTART_WINDOW_RETRY_LIMIT -gt 0 ] &amp;&amp; [ $autostartCount -gt $AUTOSTART_WINDOW_RETRY_LIMIT ]; then
        echo &quot;`date` Autostart window retry limit: $AUTOSTART_WINDOW_RETRY_LIMIT exceeded for given window size: $AUTOSTART_WINDOW_SIZE hours.. Exiting...&quot; &gt;&gt; $&#123;HBASE_LOGLOG&#125;
        rm -f &quot;$HBASE_AUTOSTART_FILE&quot;
        exit 1
      fi

      # 等待关闭的钩子完成
      sleep 20
    done
  ;;

(stop)
    echo running $command, logging to $HBASE_LOGOUT
    rm -f &quot;$HBASE_AUTOSTART_FILE&quot;
    # 判断是否存在进程号的文件
    if [ -f $HBASE_PID ]; then
      pidToKill=`cat $HBASE_PID`
      # 执行 kill -0 以确认进程是否在运行，如果在运行则传递 kill 信号，调用 hbase-common.sh 的 waitForProcessEnd 函数等待执行
      if kill -0 $pidToKill &gt; /dev/null 2&gt;&amp;1; then
        echo -n stopping $command
        echo &quot;`date` Terminating $command&quot; &gt;&gt; $HBASE_LOGLOG
        kill $pidToKill &gt; /dev/null 2&gt;&amp;1
        waitForProcessEnd $pidToKill $command
      else
        retval=$?
        echo no $command to stop because kill -0 of pid $pidToKill failed with status $retval
      fi
    else
      echo no $command to stop because no pid file $HBASE_PID
    fi
    rm -f $HBASE_PID
  ;;

(restart)
    echo running $command, logging to $HBASE_LOGOUT
    # 停止服务
    $thiscmd --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; stop $command $args &amp;
    wait_until_done $!
    # 等待用户指定的睡眠周期
    sp=$&#123;HBASE_RESTART_SLEEP:-3&#125;
    if [ $sp -gt 0 ]; then
      sleep $sp
    fi
    # 启动服务
    $thiscmd --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; start $command $args &amp;
    wait_until_done $!
  ;;

(*)
  echo $usage
  exit 1
  ;;
esac</code></pre></div><h3 id="hbase-common-sh"><a href="#hbase-common-sh" class="headerlink" title="hbase-common.sh"></a>hbase-common.sh</h3><p>仅有 waitForProcessEnd 方法，是个共享函数，用于等待进程结束，以 pid 和命令名称为参数。</p><div class="hljs code-wrapper"><pre><code class="hljs shell">waitForProcessEnd() &#123;
<span class="hljs-meta prompt_">  # </span><span class="language-bash">待停止的进程号</span>
  pidKilled=$1
<span class="hljs-meta prompt_">  # </span><span class="language-bash">服务名</span>
  commandName=$2
  processedAt=`date +%s`
<span class="hljs-meta prompt_">  # </span><span class="language-bash">判断进程是否仍在运行</span>
  while kill -0 $pidKilled &gt; /dev/null 2&gt;&amp;1;
   do
     echo -n &quot;.&quot;
     sleep 1;
     # 如果进程持续的时间超过 $HBASE_STOP_TIMEOUT 即 1200s，不再等待，继续往下执行
     if [ $(( `date +%s` - $processedAt )) -gt $&#123;HBASE_STOP_TIMEOUT:-1200&#125; ]; then
       break;
     fi
   done
<span class="hljs-meta prompt_">  # </span><span class="language-bash">如果进程仍在运行，执行 <span class="hljs-built_in">kill</span> -9</span>
  if kill -0 $pidKilled &gt; /dev/null 2&gt;&amp;1; then
    echo -n force stopping $commandName with kill -9 $pidKilled
    $JAVA_HOME/bin/jstack -l $pidKilled &gt; &quot;$logout&quot; 2&gt;&amp;1
    kill -9 $pidKilled &gt; /dev/null 2&gt;&amp;1
  fi
<span class="hljs-meta prompt_">  # </span><span class="language-bash">Add a CR after we<span class="hljs-string">&#x27;re done w/ dots.</span></span>
  echo
&#125;</code></pre></div><h3 id="zookeepers-sh"><a href="#zookeepers-sh" class="headerlink" title="zookeepers.sh"></a>zookeepers.sh</h3><p>接收 hbase-daemon.sh 中传递的参数，在所有的 Zookeeper 主机上执行命令。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">环境变量</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">配置文件目录，默认是 <span class="hljs-variable">$&#123;HBASE_HOME&#125;</span>/conf</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_CONF_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">在生成远程命令的时候睡眠的时间，默认未设置</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_SLAVE_SLEEP</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">执行远程命令时，传递给 ssh 的选项</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_SSH_OPTS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">仿照 <span class="hljs-variable">$HADOOP_HOME</span>/bin/slaves.sh</span>

usage=&quot;Usage: zookeepers [--config &lt;hbase-confdir&gt;] command...&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有指定参数，输出 usage</span>
if [ $# -le 0 ]; then
  echo $usage
  exit 1
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前路径</span>
bin=`dirname &quot;$&#123;BASH_SOURCE-$0&#125;&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载 hbase-config.sh</span>
. &quot;$bin&quot;/hbase-config.sh
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果 <span class="hljs-variable">$HBASE_MANAGES_ZK</span> 参数未配置，即 hbase-env.sh 中的 <span class="hljs-built_in">export</span> HBASE_MANAGES_ZK=<span class="hljs-literal">true</span> 注释没打开，则将此参数设置为 <span class="hljs-literal">true</span></span>
if [ &quot;$HBASE_MANAGES_ZK&quot; = &quot;&quot; ]; then
  HBASE_MANAGES_ZK=true
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">调用 <span class="hljs-variable">$bin</span>/hbase 脚本，运行 ZKServerTool 类获取 Zookeeper 所有的主机，通过 grep 和 sed 命令对结果进行处理，见附 3，$<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;@// /\\ &#125;</span>&quot;</span>会将命令中将所有的 \ 替换成为空格</span>
if [ &quot;$HBASE_MANAGES_ZK&quot; = &quot;true&quot; ]; then
  hosts=`&quot;$bin&quot;/hbase org.apache.hadoop.hbase.zookeeper.ZKServerTool | grep &#x27;^ZK host:&#x27; | sed &#x27;s,^ZK host:,,&#x27;`
  cmd=$&quot;$&#123;@// /\\ &#125;&quot;
<span class="hljs-meta prompt_">  # </span><span class="language-bash">在所有的主机上启动 Zookeeper 服务</span>
  for zookeeper in $hosts; do
   ssh $HBASE_SSH_OPTS $zookeeper $cmd 2&gt;&amp;1 | sed &quot;s/^/$zookeeper: /&quot; &amp;
   if [ &quot;$HBASE_SLAVE_SLEEP&quot; != &quot;&quot; ]; then
     sleep $HBASE_SLAVE_SLEEP
   fi
  done
fi

wait</code></pre></div><h4 id="附-3"><a href="#附-3" class="headerlink" title="附 3"></a>附 3</h4><p>通过 $bin/hbase 运行此类。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZKServerTool</span> &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ZKServerTool</span><span class="hljs-params">()</span> &#123;
    &#125;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ServerName[] readZKNodes(Configuration conf) &#123;
        List&lt;ServerName&gt; hosts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-comment">// 从 conf 中获取 hbase.zookeeper.quorum 参数对应的值，默认为 localhost</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">quorum</span> <span class="hljs-operator">=</span> conf.get(HConstants.ZOOKEEPER_QUORUM, HConstants.LOCALHOST);
        
        String[] values = quorum.split(<span class="hljs-string">&quot;,&quot;</span>);
        <span class="hljs-keyword">for</span> (String value : values) &#123;
          String[] parts = value.split(<span class="hljs-string">&quot;:&quot;</span>);
          <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> parts[<span class="hljs-number">0</span>];
          <span class="hljs-comment">// 默认端口 2181</span>
          <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> HConstants.DEFAULT_ZOOKEEPER_CLIENT_PORT;
          <span class="hljs-keyword">if</span> (parts.length &gt; <span class="hljs-number">1</span>) &#123;
            port = Integer.parseInt(parts[<span class="hljs-number">1</span>]);
          &#125;
          hosts.add(ServerName.valueOf(host, port, -<span class="hljs-number">1</span>));
        &#125;
        <span class="hljs-comment">// 转换成数组输出</span>
        <span class="hljs-keyword">return</span> hosts.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerName</span>[hosts.size()]);
    &#125;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-keyword">for</span>(ServerName server: readZKNodes(HBaseConfiguration.create())) &#123;
          <span class="hljs-comment">// bin/zookeeper.sh 依赖于 &quot;ZK host&quot; 字符串进行 grep 操作，区分大小写</span>
          System.out.println(<span class="hljs-string">&quot;ZK host: &quot;</span> + server.getHostname());
        &#125;
    &#125;
&#125;</code></pre></div><h3 id="master-backup-sh"><a href="#master-backup-sh" class="headerlink" title="master-backup.sh"></a>master-backup.sh</h3><p>接收 hbase-daemon.sh 中传递的参数，在所有的 backup master 主机上执行命令。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">环境变量</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">远程主机文件命名，默认是 <span class="hljs-variable">$&#123;HBASE_CONF_DIR&#125;</span>/backup-masters</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_BACKUP_MASTERS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">Hadoop 配置文件路径，默认是 <span class="hljs-variable">$&#123;HADOOP_HOME&#125;</span>/conf</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HADOOP_CONF_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBase 配置文件路径，默认是 <span class="hljs-variable">$&#123;HBASE_HOME&#125;</span>/conf</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_CONF_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">在生成远程命令的时候睡眠的时间，默认未设置</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_SLAVE_SLEEP</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">执行远程命令时，传递给 ssh 的选项</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_SSH_OPTS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">仿照 <span class="hljs-variable">$HADOOP_HOME</span>/bin/slaves.sh</span>

usage=&quot;Usage: $0 [--config &lt;hbase-confdir&gt;] command...&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有指定参数，输出 usage</span>
if [ $# -le 0 ]; then
  echo $usage
  exit 1
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前路径</span>
bin=`dirname &quot;$&#123;BASH_SOURCE-$0&#125;&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载 hbase-config.sh</span>
. &quot;$bin&quot;/hbase-config.sh
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果在命令行中指定了 master backup 文件，那么优先级高于 hbase-env.sh 中的配置，此处进行保存</span>
HOSTLIST=$HBASE_BACKUP_MASTERS

if [ &quot;$HOSTLIST&quot; = &quot;&quot; ]; then
  if [ &quot;$HBASE_BACKUP_MASTERS&quot; = &quot;&quot; ]; then
    export HOSTLIST=&quot;$&#123;HBASE_CONF_DIR&#125;/backup-masters&quot;
  else
    export HOSTLIST=&quot;$&#123;HBASE_BACKUP_MASTERS&#125;&quot;
  fi
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">$<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;@// /\\ &#125;</span>&quot;</span>会将命令中将所有的 \ 替换成为空格</span>
args=$&#123;@// /\\ &#125;
args=$&#123;args/master-backup/master&#125;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">登陆到每个节点上，以 backup 的方式启动 master，启动后 Zookeeper 会自动选取一个 master 作为 active，其他的都是 backup</span>
if [ -f $HOSTLIST ]; then
  for hmaster in `cat &quot;$HOSTLIST&quot;`; do
   ssh $HBASE_SSH_OPTS $hmaster $&quot;$args --backup&quot; \
     2&gt;&amp;1 | sed &quot;s/^/$hmaster: /&quot; &amp;
   if [ &quot;$HBASE_SLAVE_SLEEP&quot; != &quot;&quot; ]; then
     sleep $HBASE_SLAVE_SLEEP
   fi
  done
fi 

wait</code></pre></div><h3 id="regionservers-sh"><a href="#regionservers-sh" class="headerlink" title="regionservers.sh"></a>regionservers.sh</h3><p>接收 hbase-daemon.sh 中传递的参数，在所有的 RegionServer 主机上执行命令。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">环境变量</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">远程主机文件命名，默认是 <span class="hljs-variable">$&#123;HADOOP_CONF_DIR&#125;</span>/regionservers</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_REGIONSERVERS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">Hadoop 配置文件路径，默认是 <span class="hljs-variable">$&#123;HADOOP_HOME&#125;</span>/conf</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HADOOP_CONF_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBase 配置文件路径，默认是 <span class="hljs-variable">$&#123;HBASE_HOME&#125;</span>/conf</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_CONF_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">在生成远程命令的时候睡眠的时间，默认未设置</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_SLAVE_SLEEP</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">执行远程命令时，传递给 ssh 的选项</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_SSH_OPTS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">仿照 <span class="hljs-variable">$HADOOP_HOME</span>/bin/slaves.sh</span>

usage=&quot;Usage: regionservers [--config &lt;hbase-confdir&gt;] command...&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有指定参数，输出 usage</span>
if [ $# -le 0 ]; then
  echo $usage
  exit 1
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前路径</span>
bin=`dirname &quot;$&#123;BASH_SOURCE-$0&#125;&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`

. &quot;$bin&quot;/hbase-config.sh
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果在命令行中指定了 regionservers 文件，那么优先级高于 hbase-env.sh 中的配置，此处进行保存</span>
HOSTLIST=$HBASE_REGIONSERVERS

if [ &quot;$HOSTLIST&quot; = &quot;&quot; ]; then
  if [ &quot;$HBASE_REGIONSERVERS&quot; = &quot;&quot; ]; then
    export HOSTLIST=&quot;$&#123;HBASE_CONF_DIR&#125;/regionservers&quot;
  else
    export HOSTLIST=&quot;$&#123;HBASE_REGIONSERVERS&#125;&quot;
  fi
fi

regionservers=`cat &quot;$HOSTLIST&quot;`
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果 regionservers 是默认的 localhost，则会在本地启动 regionserver，集群模式则按顺序在各个节点上启动 RegionServer，$<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;@// /\\ &#125;</span>&quot;</span>会将命令中将所有的 \ 替换成为空格</span>
if [ &quot;$regionservers&quot; = &quot;localhost&quot; ]; then
  HBASE_REGIONSERVER_ARGS=&quot;\
    -Dhbase.regionserver.port=16020 \
    -Dhbase.regionserver.info.port=16030&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_">  $</span><span class="language-bash"><span class="hljs-string">&quot;<span class="hljs-variable">$&#123;@// /\\ &#125;</span>&quot;</span> <span class="hljs-variable">$&#123;HBASE_REGIONSERVER_ARGS&#125;</span> \</span>
<span class="language-bash">        2&gt;&amp;1 | sed <span class="hljs-string">&quot;s/^/<span class="hljs-variable">$regionserver</span>: /&quot;</span> &amp;</span>
else
  for regionserver in `cat &quot;$HOSTLIST&quot;`; do
    if $&#123;HBASE_SLAVE_PARALLEL:-true&#125;; then
      ssh $HBASE_SSH_OPTS $regionserver $&quot;$&#123;@// /\\ &#125;&quot; \
        2&gt;&amp;1 | sed &quot;s/^/$regionserver: /&quot; &amp;
    else # run each command serially
      ssh $HBASE_SSH_OPTS $regionserver $&quot;$&#123;@// /\\ &#125;&quot; \
        2&gt;&amp;1 | sed &quot;s/^/$regionserver: /&quot;
    fi
    if [ &quot;$HBASE_SLAVE_SLEEP&quot; != &quot;&quot; ]; then
      sleep $HBASE_SLAVE_SLEEP
    fi
  done
fi

wait</code></pre></div><h3 id="bin-hbase"><a href="#bin-hbase" class="headerlink" title="bin/hbase"></a>bin/hbase</h3><p>hbase 命令脚本，基于 hadoop 命令脚本，它在 hadoop 脚本之前完成了相关配置。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">环境变量</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">要使用的 java 实现，覆盖 JAVA_HOME</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">JAVA_HOME</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">额外的 Java CLASSPATH</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_CLASSPATH</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">作为 system classpath 的额外 Java CLASSPATH 的前缀</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_CLASSPATH_PREFIX</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">使用的最大堆数量，默认未设置，并使用 JVM 的默认设置，通常是可用内存的 1/4</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_HEAPSIZE</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">对 JAVA_LIBRARY_PATH 的 HBase 添加，用于添加本机库</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_LIBRARY_PATH</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">额外的 Java 运行时选项</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_OPTS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBase 配置文件路径，默认是 <span class="hljs-variable">$&#123;HBASE_HOME&#125;</span>/conf</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_CONF_DIR</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_">#</span><span class="language-bash">日志追加器，默认是控制台 INFO 级别</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">HBASE_ROOT_LOGGER</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">JRuby路径：<span class="hljs-variable">$JRUBY_HOME</span>/lib/jruby.jar 应该存在，默认为 HBase 打包的jar</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">JRUBY_HOME</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">额外的选项（例如<span class="hljs-string">&#x27;--1.9&#x27;</span>）传递给了 hbase，默认为空</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">JRUBY_OPTS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">额外的传递给 hbase shell 的选项，默认为空</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">  HBASE_SHELL_OPTS</span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取当前目录</span>
bin=`dirname &quot;$0&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载 hbase-config.sh 获取配置</span>
. &quot;$bin&quot;/hbase-config.sh
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">检测系统，是否使用 cygwin</span>
cygwin=false
case &quot;`uname`&quot; in
CYGWIN*) cygwin=true;;
esac
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">检测当前是否在 HBase 的根目录中</span>
in_dev_env=false
if [ -d &quot;$&#123;HBASE_HOME&#125;/target&quot; ]; then
  in_dev_env=true
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">检测是否在综合压缩包中</span>
in_omnibus_tarball=&quot;false&quot;
if [ -f &quot;$&#123;HBASE_HOME&#125;/bin/hbase-daemons.sh&quot; ]; then
  in_omnibus_tarball=&quot;true&quot;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">read</span> 当读到 <span class="hljs-string">&#x27;&#x27;</span> 即结束，此处作为一部分用法进行输出</span>
read -d &#x27;&#x27; options_string &lt;&lt; EOF
Options:
  --config DIR         Configuration direction to use. Default: ./conf
  --hosts HOSTS        Override the list in &#x27;regionservers&#x27; file
  --auth-as-server     Authenticate to ZooKeeper using servers configuration
  --internal-classpath Skip attempting to use client facing jars (WARNING: unstable results between versions)
EOF
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有指定参数，输出 usage，包含上面的内容</span>
if [ $# = 0 ]; then
  echo &quot;Usage: hbase [&lt;options&gt;] &lt;command&gt; [&lt;args&gt;]&quot;
  echo &quot;$options_string&quot;
  echo &quot;&quot;
  echo &quot;Commands:&quot;
  echo &quot;Some commands take arguments. Pass no args or -h for usage.&quot;
  echo &quot;  shell            Run the HBase shell&quot;
  echo &quot;  hbck             Run the HBase &#x27;fsck&#x27; tool. Defaults read-only hbck1.&quot;
  echo &quot;                   Pass &#x27;-j /path/to/HBCK2.jar&#x27; to run hbase-2.x HBCK2.&quot;
  echo &quot;  snapshot         Tool for managing snapshots&quot;
  if [ &quot;$&#123;in_omnibus_tarball&#125;&quot; = &quot;true&quot; ]; then
    echo &quot;  wal              Write-ahead-log analyzer&quot;
    echo &quot;  hfile            Store file analyzer&quot;
    echo &quot;  zkcli            Run the ZooKeeper shell&quot;
    echo &quot;  master           Run an HBase HMaster node&quot;
    echo &quot;  regionserver     Run an HBase HRegionServer node&quot;
    echo &quot;  zookeeper        Run a ZooKeeper server&quot;
    echo &quot;  rest             Run an HBase REST server&quot;
    echo &quot;  thrift           Run the HBase Thrift server&quot;
    echo &quot;  thrift2          Run the HBase Thrift2 server&quot;
    echo &quot;  clean            Run the HBase clean up script&quot;
  fi
  echo &quot;  classpath        Dump hbase CLASSPATH&quot;
  echo &quot;  mapredcp         Dump CLASSPATH entries required by mapreduce&quot;
  echo &quot;  pe               Run PerformanceEvaluation&quot;
  echo &quot;  ltt              Run LoadTestTool&quot;
  echo &quot;  canary           Run the Canary tool&quot;
  echo &quot;  version          Print the version&quot;
  echo &quot;  completebulkload Run BulkLoadHFiles tool&quot;
  echo &quot;  regionsplitter   Run RegionSplitter tool&quot;
  echo &quot;  rowcounter       Run RowCounter tool&quot;
  echo &quot;  cellcounter      Run CellCounter tool&quot;
  echo &quot;  pre-upgrade      Run Pre-Upgrade validator tool&quot;
  echo &quot;  hbtop            Run HBTop tool&quot;
  echo &quot;  CLASSNAME        Run the class named CLASSNAME&quot;
  exit 1
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">获取传入的第一个参数</span>
COMMAND=$1
<span class="hljs-meta prompt_"># </span><span class="language-bash">命令左移</span>
shift

JAVA=$JAVA_HOME/bin/java
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">覆盖此命令的默认设置（如果适用）</span>
if [ -f &quot;$HBASE_HOME/conf/hbase-env-$COMMAND.sh&quot; ]; then
  . &quot;$HBASE_HOME/conf/hbase-env-$COMMAND.sh&quot;
fi

add_size_suffix() &#123;
    # 如果参数缺少一个，则添加一个“m”后缀
    local val=&quot;$1&quot;
    local lastchar=$&#123;val: -1&#125;
    if [[ &quot;mMgG&quot; == *$lastchar* ]]; then
        echo $val
    else
        echo $&#123;val&#125;m
    fi
&#125;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">检测 HBASE_HEAPSIZE 是否设置</span>
if [[ -n &quot;$HBASE_HEAPSIZE&quot; ]]; then
    JAVA_HEAP_MAX=&quot;-Xmx$(add_size_suffix $HBASE_HEAPSIZE)&quot;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">检测 HBASE_OFFHEAPSIZE 是否设置</span>
if [[ -n &quot;$HBASE_OFFHEAPSIZE&quot; ]]; then
    JAVA_OFFHEAP_MAX=&quot;-XX:MaxDirectMemorySize=$(add_size_suffix $HBASE_OFFHEAPSIZE)&quot;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">这样在下面的循环中可以正确处理带空格的文件名，设置 IFS</span>
ORIG_IFS=$IFS
IFS=
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">CLASSPATH 初始化包含 HBASE_CONF_DIR</span>
CLASSPATH=&quot;$&#123;HBASE_CONF_DIR&#125;&quot;
CLASSPATH=$&#123;CLASSPATH&#125;:$JAVA_HOME/lib/tools.jar
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果传入的文件存在，则加入 CLASSPATH</span>
add_to_cp_if_exists() &#123;
  if [ -d &quot;$@&quot; ]; then
    CLASSPATH=$&#123;CLASSPATH&#125;:&quot;$@&quot;
  fi
&#125;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">对于发行版，将 hbase 和 webapp 添加到 CLASSPATH 中 Webapp 必须首先出现，否则会使 Jetty 混乱</span>
if [ -d &quot;$HBASE_HOME/hbase-webapps&quot; ]; then
  add_to_cp_if_exists &quot;$&#123;HBASE_HOME&#125;&quot;
fi
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果在开发环境中则添加</span>
if [ -d &quot;$HBASE_HOME/hbase-server/target/hbase-webapps&quot; ]; then
  if [ &quot;$COMMAND&quot; = &quot;thrift&quot; ] ; then
    add_to_cp_if_exists &quot;$&#123;HBASE_HOME&#125;/hbase-thrift/target&quot;
  elif [ &quot;$COMMAND&quot; = &quot;thrift2&quot; ] ; then
    add_to_cp_if_exists &quot;$&#123;HBASE_HOME&#125;/hbase-thrift/target&quot;
  elif [ &quot;$COMMAND&quot; = &quot;rest&quot; ] ; then
    add_to_cp_if_exists &quot;$&#123;HBASE_HOME&#125;/hbase-rest/target&quot;
  else
    add_to_cp_if_exists &quot;$&#123;HBASE_HOME&#125;/hbase-server/target&quot;
    # 需要下面的 GetJavaProperty 检查
    add_to_cp_if_exists &quot;$&#123;HBASE_HOME&#125;/hbase-server/target/classes&quot;
  fi
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果可用，将 Hadoop 添加到 CLASSPATH 和 JAVA_LIBRARY_PATH，允许禁用此功能</span>
if [ &quot;$HBASE_DISABLE_HADOOP_CLASSPATH_LOOKUP&quot; != &quot;true&quot; ] ; then
  HADOOP_IN_PATH=$(PATH=&quot;$&#123;HADOOP_HOME:-$&#123;HADOOP_PREFIX&#125;&#125;/bin:$PATH&quot; which hadoop 2&gt;/dev/null)
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">声明 shaded_jar，将 libs 添加到 CLASSPATH</span>
declare shaded_jar

if [ &quot;$&#123;INTERNAL_CLASSPATH&#125;&quot; != &quot;true&quot; ]; then
<span class="hljs-meta prompt_">  # </span><span class="language-bash">find our shaded jars</span>
  declare shaded_client
  declare shaded_client_byo_hadoop
  declare shaded_mapreduce
  for f in &quot;$&#123;HBASE_HOME&#125;&quot;/lib/shaded-clients/hbase-shaded-client*.jar; do
    if [[ &quot;$&#123;f&#125;&quot; =~ byo-hadoop ]]; then
      shaded_client_byo_hadoop=&quot;$&#123;f&#125;&quot;
    else
      shaded_client=&quot;$&#123;f&#125;&quot;
    fi
  done
  for f in &quot;$&#123;HBASE_HOME&#125;&quot;/lib/shaded-clients/hbase-shaded-mapreduce*.jar; do
    shaded_mapreduce=&quot;$&#123;f&#125;&quot;
  done
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_">  # </span><span class="language-bash">如果命令可以使用 shaded client，使用它</span>
  declare -a commands_in_client_jar=(&quot;classpath&quot; &quot;version&quot; &quot;hbtop&quot;)
  for c in &quot;$&#123;commands_in_client_jar[@]&#125;&quot;; do
    if [ &quot;$&#123;COMMAND&#125;&quot; = &quot;$&#123;c&#125;&quot; ]; then
      if [ -n &quot;$&#123;HADOOP_IN_PATH&#125;&quot; ] &amp;&amp; [ -f &quot;$&#123;HADOOP_IN_PATH&#125;&quot; ]; then
        # 如果上面没有找到一个 jar，它将为空，然后下面的检查将默认返回内部类路径
        shaded_jar=&quot;$&#123;shaded_client_byo_hadoop&#125;&quot;
      else
        # 如果上面没有找到一个jar，它将为空，然后下面的检查将默认返回内部类路径
        shaded_jar=&quot;$&#123;shaded_client&#125;&quot;
      fi
      break
    fi
  done
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_">  # </span><span class="language-bash">如果命令需要 shaded mapreduce，使用它</span>
<span class="hljs-meta prompt_">  # </span><span class="language-bash">此处不包含 N.B “mapredcp”，因为在 shaded 情况下，它会跳过我们构建的类路径</span>
  declare -a commands_in_mr_jar=(&quot;hbck&quot; &quot;snapshot&quot; &quot;canary&quot; &quot;regionsplitter&quot; &quot;pre-upgrade&quot;)
  for c in &quot;$&#123;commands_in_mr_jar[@]&#125;&quot;; do
    if [ &quot;$&#123;COMMAND&#125;&quot; = &quot;$&#123;c&#125;&quot; ]; then
      # 如果上面没有找到一个jar，它将为空，然后下面的检查将默认返回内部类路径
      shaded_jar=&quot;$&#123;shaded_mapreduce&#125;&quot;
      break
    fi
  done
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_">  # </span><span class="language-bash">当我们在运行时获得完整的 hadoop 类路径时，某些命令专门只能使用 shaded mapreduce</span>
  if [ -n &quot;$&#123;HADOOP_IN_PATH&#125;&quot; ] &amp;&amp; [ -f &quot;$&#123;HADOOP_IN_PATH&#125;&quot; ]; then
    declare -a commands_in_mr_need_hadoop=(&quot;backup&quot; &quot;restore&quot; &quot;rowcounter&quot; &quot;cellcounter&quot;)
    for c in &quot;$&#123;commands_in_mr_need_hadoop[@]&#125;&quot;; do
      if [ &quot;$&#123;COMMAND&#125;&quot; = &quot;$&#123;c&#125;&quot; ]; then
        # 如果上面没有找到一个jar，它将为空，然后下面的检查将默认返回内部类路径
        shaded_jar=&quot;$&#123;shaded_mapreduce&#125;&quot;
        break
      fi
    done
  fi
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载相关 jar 包</span>
if [ -n &quot;$&#123;shaded_jar&#125;&quot; ] &amp;&amp; [ -f &quot;$&#123;shaded_jar&#125;&quot; ]; then
  CLASSPATH=&quot;$&#123;CLASSPATH&#125;:$&#123;shaded_jar&#125;&quot;
<span class="hljs-meta prompt_"># </span><span class="language-bash">fall through to grabbing all the lib jars and hope we<span class="hljs-string">&#x27;re in the omnibus tarball</span></span>
<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string"></span></span>
<span class="hljs-string"><span class="language-bash"># N.B. shell specifically can&#x27;</span>t rely on the shaded artifacts because RSGroups is only</span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">available as non-shaded</span>
<span class="hljs-meta prompt_">#</span><span class="language-bash"></span>
<span class="language-bash"><span class="hljs-comment"># N.B. pe and ltt can&#x27;t easily rely on shaded artifacts because they live in hbase-mapreduce:test-jar</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">and need some other jars that haven<span class="hljs-string">&#x27;t been relocated. Currently enumerating that list</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">is too hard to be worth it.</span></span>
<span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string"></span></span>
<span class="hljs-string"><span class="language-bash">else</span></span>
  for f in $HBASE_HOME/lib/*.jar; do
    CLASSPATH=$&#123;CLASSPATH&#125;:$f;
  done
<span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">make it easier to check for shaded/not later on.</span></span>
  shaded_jar=&quot;&quot;
fi
for f in &quot;$&#123;HBASE_HOME&#125;&quot;/lib/client-facing-thirdparty/*.jar; do
  if [[ ! &quot;$&#123;f&#125;&quot; =~ ^.*/htrace-core-3.*\.jar$ ]] &amp;&amp; \
     [ &quot;$&#123;f&#125;&quot; != &quot;htrace-core.jar$&quot; ] &amp;&amp; \
     [[ ! &quot;$&#123;f&#125;&quot; =~ ^.*/slf4j-log4j.*$ ]]; then
    CLASSPATH=&quot;$&#123;CLASSPATH&#125;:$&#123;f&#125;&quot;
  fi
done
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">默认的日志文件目录</span></span>
if [ &quot;$HBASE_LOG_DIR&quot; = &quot;&quot; ]; then
  HBASE_LOG_DIR=&quot;$HBASE_HOME/logs&quot;
fi
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">默认的日志名</span></span>
if [ &quot;$HBASE_LOGFILE&quot; = &quot;&quot; ]; then
  HBASE_LOGFILE=&#x27;hbase.log&#x27;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">组装 jar</span></span>
function append_path() &#123;
  if [ -z &quot;$1&quot; ]; then
    echo &quot;$2&quot;
  else
    echo &quot;$1:$2&quot;
  fi
&#125;

JAVA_PLATFORM=&quot;&quot;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">如果定义了 HBASE_LIBRARY_PATH，则将其用作第一个或第二个选项</span></span>
if [ &quot;$HBASE_LIBRARY_PATH&quot; != &quot;&quot; ]; then
  JAVA_LIBRARY_PATH=$(append_path &quot;$JAVA_LIBRARY_PATH&quot; &quot;$HBASE_LIBRARY_PATH&quot;)
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">如果已配置并且可用，则将 Hadoop 添加到 CLASSPATH 和 JAVA_LIBRARY_PATH</span></span>
if [ -n &quot;$&#123;HADOOP_IN_PATH&#125;&quot; ] &amp;&amp; [ -f &quot;$&#123;HADOOP_IN_PATH&#125;&quot; ]; then
<span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">如果构建了 hbase，则将 hbase-server.jar 临时添加到 GetJavaProperty 的类路径中</span></span>
<span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">排除 hbase-server*-tests.jar</span></span>
  temporary_cp=
  for f in &quot;$&#123;HBASE_HOME&#125;&quot;/lib/hbase-server*.jar; do
    if [[ ! &quot;$&#123;f&#125;&quot; =~ ^.*\-tests\.jar$ ]]; then
      temporary_cp=&quot;:$f&quot;
    fi
  done
  HADOOP_JAVA_LIBRARY_PATH=$(HADOOP_CLASSPATH=&quot;$CLASSPATH$&#123;temporary_cp&#125;&quot; &quot;$&#123;HADOOP_IN_PATH&#125;&quot; \
                             org.apache.hadoop.hbase.util.GetJavaProperty java.library.path)
  if [ -n &quot;$HADOOP_JAVA_LIBRARY_PATH&quot; ]; then
    JAVA_LIBRARY_PATH=$(append_path &quot;$&#123;JAVA_LIBRARY_PATH&#125;&quot; &quot;$HADOOP_JAVA_LIBRARY_PATH&quot;)
  fi
  CLASSPATH=$(append_path &quot;$&#123;CLASSPATH&#125;&quot; &quot;$($&#123;HADOOP_IN_PATH&#125; classpath 2&gt;/dev/null)&quot;)
else
<span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">否则，如果我们提供的是 Hadoop，我们还需要使用它的版本构建，则应包括 htrace 3</span></span>
  for f in &quot;$&#123;HBASE_HOME&#125;&quot;/lib/client-facing-thirdparty/htrace-core-3*.jar &quot;$&#123;HBASE_HOME&#125;&quot;/lib/client-facing-thirdparty/htrace-core.jar; do
    if [ -f &quot;$&#123;f&#125;&quot; ]; then
      CLASSPATH=&quot;$&#123;CLASSPATH&#125;:$&#123;f&#125;&quot;
      break
    fi
  done
<span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">使用 shaded jars 时，某些命令需要特殊处理。对于这些情况，我们依赖于 hbase-shaded-mapreduce 而不是 hbase-shaded-client*，因为我们利用了一些 IA.Private 类，这些私有类不再后者中。但是我们不使用&quot;hadoop jar&quot;来调用它们，因此当我们不执行运行时 hadoop 类路径查找时，我们需要确保有一些 Hadoop 类可用。</span></span>
<span class="hljs-meta prompt_"> # </span><span class="language-bash"><span class="hljs-string">我们需要的一组类是打包在 shaded-client 中的那些类</span></span>
  for c in &quot;$&#123;commands_in_mr_jar[@]&#125;&quot;; do
    if [ &quot;$&#123;COMMAND&#125;&quot; = &quot;$&#123;c&#125;&quot; ] &amp;&amp; [ -n &quot;$&#123;shaded_jar&#125;&quot; ]; then
      CLASSPATH=&quot;$&#123;CLASSPATH&#125;:$&#123;shaded_client:?We couldn\&#x27;t find the shaded client jar even though we did find the shaded MR jar. for command $&#123;COMMAND&#125; we need both. please use --internal-classpath as a workaround.&#125;&quot;
      break
    fi
  done
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">最后添加用户指定的 CLASSPATH</span></span>
if [ &quot;$HBASE_CLASSPATH&quot; != &quot;&quot; ]; then
  CLASSPATH=$&#123;CLASSPATH&#125;:$&#123;HBASE_CLASSPATH&#125;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">首先添加用户指定的 CLASSPATH 前缀</span></span>
if [ &quot;$HBASE_CLASSPATH_PREFIX&quot; != &quot;&quot; ]; then
  CLASSPATH=$&#123;HBASE_CLASSPATH_PREFIX&#125;:$&#123;CLASSPATH&#125;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">cygwin 路径转换</span></span>
if $cygwin; then
  CLASSPATH=`cygpath -p -w &quot;$CLASSPATH&quot;`
  HBASE_HOME=`cygpath -d &quot;$HBASE_HOME&quot;`
  HBASE_LOG_DIR=`cygpath -d &quot;$HBASE_LOG_DIR&quot;`
fi

if [ -d &quot;$&#123;HBASE_HOME&#125;/build/native&quot; -o -d &quot;$&#123;HBASE_HOME&#125;/lib/native&quot; ]; then
  if [ -z $JAVA_PLATFORM ]; then
    JAVA_PLATFORM=`CLASSPATH=$&#123;CLASSPATH&#125; $&#123;JAVA&#125; org.apache.hadoop.util.PlatformName | sed -e &quot;s/ /_/g&quot;`
  fi
  if [ -d &quot;$HBASE_HOME/build/native&quot; ]; then
    JAVA_LIBRARY_PATH=$(append_path &quot;$JAVA_LIBRARY_PATH&quot; &quot;$&#123;HBASE_HOME&#125;/build/native/$&#123;JAVA_PLATFORM&#125;/lib&quot;)
  fi

  if [ -d &quot;$&#123;HBASE_HOME&#125;/lib/native&quot; ]; then
    JAVA_LIBRARY_PATH=$(append_path &quot;$JAVA_LIBRARY_PATH&quot; &quot;$&#123;HBASE_HOME&#125;/lib/native/$&#123;JAVA_PLATFORM&#125;&quot;)
  fi
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">cygwin 路径转换</span></span>
if $cygwin; then
  JAVA_LIBRARY_PATH=`cygpath -p &quot;$JAVA_LIBRARY_PATH&quot;`
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">清除循环中的 IFS</span></span>
unset IFS
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">根据我们所运行的设置正确的 GC 选项</span></span>
declare -a server_cmds=(&quot;master&quot; &quot;regionserver&quot; &quot;thrift&quot; &quot;thrift2&quot; &quot;rest&quot; &quot;avro&quot; &quot;zookeeper&quot;)
for cmd in $&#123;server_cmds[@]&#125;; do
	if [[ $cmd == $COMMAND ]]; then
		server=true
		break
	fi
done

if [[ $server ]]; then
	HBASE_OPTS=&quot;$HBASE_OPTS $SERVER_GC_OPTS&quot;
else
	HBASE_OPTS=&quot;$HBASE_OPTS $CLIENT_GC_OPTS&quot;
fi

if [ &quot;$AUTH_AS_SERVER&quot; == &quot;true&quot; ] || [ &quot;$COMMAND&quot; = &quot;hbck&quot; ]; then
   if [ -n &quot;$HBASE_SERVER_JAAS_OPTS&quot; ]; then
     HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_SERVER_JAAS_OPTS&quot;
   else
     HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_REGIONSERVER_OPTS&quot;
   fi
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">检测命令是否需要 jline</span></span>
declare -a jline_cmds=(&quot;zkcli&quot; &quot;org.apache.hadoop.hbase.zookeeper.ZKMainServer&quot;)
for cmd in &quot;$&#123;jline_cmds[@]&#125;&quot;; do
  if [[ $cmd == &quot;$COMMAND&quot; ]]; then
    jline_needed=true
    break
  fi
done
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">for jruby</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">(1) for the commands which need jruby (see jruby_cmds defined below)</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    A. when JRUBY_HOME is specified explicitly, eg. export JRUBY_HOME=/usr/local/share/jruby</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">       CLASSPATH and HBASE_OPTS are updated according to JRUBY_HOME specified</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    B. when JRUBY_HOME is not specified explicitly</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">       add jruby packaged with HBase to CLASSPATH</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">(2) for other commands, do nothing</span></span>
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">检测命令是否需要 jruby</span></span>
declare -a jruby_cmds=(&quot;shell&quot; &quot;org.jruby.Main&quot;)
for cmd in &quot;$&#123;jruby_cmds[@]&#125;&quot;; do
  if [[ $cmd == &quot;$COMMAND&quot; ]]; then
    jruby_needed=true
    break
  fi
done

add_maven_deps_to_classpath() &#123;
  f=&quot;$&#123;HBASE_HOME&#125;/hbase-build-configuration/target/$1&quot;

  if [ ! -f &quot;$&#123;f&#125;&quot; ]; then
      echo &quot;As this is a development environment, we need $&#123;f&#125; to be generated from maven (command: mvn install -DskipTests)&quot;
      exit 1
  fi
  CLASSPATH=$&#123;CLASSPATH&#125;:$(cat &quot;$&#123;f&#125;&quot;)
&#125;
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">添加开发环境类路径的东西</span></span>
if $in_dev_env; then
  add_maven_deps_to_classpath &quot;cached_classpath.txt&quot;

  if [[ $jline_needed ]]; then
    add_maven_deps_to_classpath &quot;cached_classpath_jline.txt&quot;
  elif [[ $jruby_needed ]]; then
    add_maven_deps_to_classpath &quot;cached_classpath_jruby.txt&quot;
  fi
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">命令需要 jruby</span></span>
if [[ $jruby_needed ]]; then
  if [ &quot;$JRUBY_HOME&quot; != &quot;&quot; ]; then  # JRUBY_HOME is specified explicitly, eg. export JRUBY_HOME=/usr/local/share/jruby
    # add jruby.jar into CLASSPATH
    CLASSPATH=&quot;$JRUBY_HOME/lib/jruby.jar:$CLASSPATH&quot;

    # add jruby to HBASE_OPTS
    HBASE_OPTS=&quot;$HBASE_OPTS -Djruby.home=$JRUBY_HOME -Djruby.lib=$JRUBY_HOME/lib&quot;

  else  # JRUBY_HOME is not specified explicitly
    if ! $in_dev_env; then  # not in dev environment
      # add jruby packaged with HBase to CLASSPATH
      JRUBY_PACKAGED_WITH_HBASE=&quot;$HBASE_HOME/lib/ruby/*.jar&quot;
      for jruby_jar in $JRUBY_PACKAGED_WITH_HBASE; do
        CLASSPATH=$jruby_jar:$CLASSPATH;
      done
    fi
  fi
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">找出要运行的 class，该脚本可用于直接运行 Java 类</span></span>
if [ &quot;$COMMAND&quot; = &quot;shell&quot; ] ; then
<span class="hljs-meta prompt_">	#</span><span class="language-bash"><span class="hljs-string">find the hbase ruby sources</span></span>
  if [ -d &quot;$HBASE_HOME/lib/ruby&quot; ]; then
    HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.ruby.sources=$HBASE_HOME/lib/ruby&quot;
  else
    HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.ruby.sources=$HBASE_HOME/hbase-shell/src/main/ruby&quot;
  fi
  HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_SHELL_OPTS&quot;
  CLASS=&quot;org.jruby.Main -X+O $&#123;JRUBY_OPTS&#125; $&#123;HBASE_HOME&#125;/bin/hirb.rb&quot;
elif [ &quot;$COMMAND&quot; = &quot;hbck&quot; ] ; then
<span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">Look for the -j /path/to/HBCK2.jar parameter. Else pass through to hbck.</span></span>
  case &quot;$&#123;1&#125;&quot; in
    -j)
    # Found -j parameter. Add arg to CLASSPATH and set CLASS to HBCK2.
    shift
    JAR=&quot;$&#123;1&#125;&quot;
    if [ ! -f &quot;$&#123;JAR&#125;&quot; ]; then
      echo &quot;$&#123;JAR&#125; file not found!&quot;
      echo &quot;Usage: hbase [&lt;options&gt;] hbck -jar /path/to/HBCK2.jar [&lt;args&gt;]&quot;
      exit 1
    fi
    CLASSPATH=&quot;$&#123;JAR&#125;:$&#123;CLASSPATH&#125;&quot;;
    CLASS=&quot;org.apache.hbase.HBCK2&quot;
    shift # past argument=value
    ;;
    *)
    CLASS=&#x27;org.apache.hadoop.hbase.util.HBaseFsck&#x27;
    ;;
  esac
elif [ &quot;$COMMAND&quot; = &quot;wal&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.wal.WALPrettyPrinter&#x27;
elif [ &quot;$COMMAND&quot; = &quot;hfile&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.io.hfile.HFilePrettyPrinter&#x27;
elif [ &quot;$COMMAND&quot; = &quot;zkcli&quot; ] ; then
  CLASS=&quot;org.apache.hadoop.hbase.zookeeper.ZKMainServer&quot;
  for f in $HBASE_HOME/lib/zkcli/*.jar; do
    CLASSPATH=&quot;$&#123;CLASSPATH&#125;:$f&quot;;
  done
elif [ &quot;$COMMAND&quot; = &quot;upgrade&quot; ] ; then
  echo &quot;This command was used to upgrade to HBase 0.96, it was removed in HBase 2.0.0.&quot;
  echo &quot;Please follow the documentation at http://hbase.apache.org/book.html#upgrading.&quot;
  exit 1
elif [ &quot;$COMMAND&quot; = &quot;snapshot&quot; ] ; then
  SUBCOMMAND=$1
  shift
  if [ &quot;$SUBCOMMAND&quot; = &quot;create&quot; ] ; then
    CLASS=&quot;org.apache.hadoop.hbase.snapshot.CreateSnapshot&quot;
  elif [ &quot;$SUBCOMMAND&quot; = &quot;info&quot; ] ; then
    CLASS=&quot;org.apache.hadoop.hbase.snapshot.SnapshotInfo&quot;
  elif [ &quot;$SUBCOMMAND&quot; = &quot;export&quot; ] ; then
    CLASS=&quot;org.apache.hadoop.hbase.snapshot.ExportSnapshot&quot;
  else
    echo &quot;Usage: hbase [&lt;options&gt;] snapshot &lt;subcommand&gt; [&lt;args&gt;]&quot;
    echo &quot;$options_string&quot;
    echo &quot;&quot;
    echo &quot;Subcommands:&quot;
    echo &quot;  create          Create a new snapshot of a table&quot;
    echo &quot;  info            Tool for dumping snapshot information&quot;
    echo &quot;  export          Export an existing snapshot&quot;
    exit 1
  fi
elif [ &quot;$COMMAND&quot; = &quot;master&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.master.HMaster&#x27;
  if [ &quot;$1&quot; != &quot;stop&quot; ] &amp;&amp; [ &quot;$1&quot; != &quot;clear&quot; ] ; then
    HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_MASTER_OPTS&quot;
  fi
elif [ &quot;$COMMAND&quot; = &quot;regionserver&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.regionserver.HRegionServer&#x27;
  if [ &quot;$1&quot; != &quot;stop&quot; ] ; then
    HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_REGIONSERVER_OPTS&quot;
  fi
elif [ &quot;$COMMAND&quot; = &quot;thrift&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.thrift.ThriftServer&#x27;
  if [ &quot;$1&quot; != &quot;stop&quot; ] ; then
    HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_THRIFT_OPTS&quot;
  fi
elif [ &quot;$COMMAND&quot; = &quot;thrift2&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.thrift2.ThriftServer&#x27;
  if [ &quot;$1&quot; != &quot;stop&quot; ] ; then
    HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_THRIFT_OPTS&quot;
  fi
elif [ &quot;$COMMAND&quot; = &quot;rest&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.rest.RESTServer&#x27;
  if [ &quot;$1&quot; != &quot;stop&quot; ] ; then
    HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_REST_OPTS&quot;
  fi
elif [ &quot;$COMMAND&quot; = &quot;zookeeper&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.zookeeper.HQuorumPeer&#x27;
  if [ &quot;$1&quot; != &quot;stop&quot; ] ; then
    HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_ZOOKEEPER_OPTS&quot;
  fi
elif [ &quot;$COMMAND&quot; = &quot;clean&quot; ] ; then
  case $1 in
    --cleanZk|--cleanHdfs|--cleanAll)
      matches=&quot;yes&quot; ;;
    *) ;;
  esac
  if [ $# -ne 1 -o &quot;$matches&quot; = &quot;&quot; ]; then
    echo &quot;Usage: hbase clean (--cleanZk|--cleanHdfs|--cleanAll)&quot;
    echo &quot;Options: &quot;
    echo &quot;        --cleanZk   cleans hbase related data from zookeeper.&quot;
    echo &quot;        --cleanHdfs cleans hbase related data from hdfs.&quot;
    echo &quot;        --cleanAll  cleans hbase related data from both zookeeper and hdfs.&quot;
    exit 1;
  fi
  &quot;$bin&quot;/hbase-cleanup.sh --config $&#123;HBASE_CONF_DIR&#125; $@
  exit $?
elif [ &quot;$COMMAND&quot; = &quot;mapredcp&quot; ] ; then
<span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-string">If we didn&#x27;</span>t find a jar above, this will just be blank and the</span>
<span class="hljs-meta prompt_">  # </span><span class="language-bash">check below will <span class="hljs-keyword">then</span> default back to the internal classpath.</span>
  shaded_jar=&quot;$&#123;shaded_mapreduce&#125;&quot;
  if [ &quot;$&#123;INTERNAL_CLASSPATH&#125;&quot; != &quot;true&quot; ] &amp;&amp; [ -f &quot;$&#123;shaded_jar&#125;&quot; ]; then
    echo -n &quot;$&#123;shaded_jar&#125;&quot;
    for f in &quot;$&#123;HBASE_HOME&#125;&quot;/lib/client-facing-thirdparty/*.jar; do
      if [[ ! &quot;$&#123;f&#125;&quot; =~ ^.*/htrace-core-3.*\.jar$ ]] &amp;&amp; \
         [ &quot;$&#123;f&#125;&quot; != &quot;htrace-core.jar$&quot; ] &amp;&amp; \
         [[ ! &quot;$&#123;f&#125;&quot; =~ ^.*/slf4j-log4j.*$ ]]; then
        echo -n &quot;:$&#123;f&#125;&quot;
      fi
    done
    echo &quot;&quot;
    exit 0
  fi
  CLASS=&#x27;org.apache.hadoop.hbase.util.MapreduceDependencyClasspathTool&#x27;
elif [ &quot;$COMMAND&quot; = &quot;classpath&quot; ] ; then
  echo &quot;$CLASSPATH&quot;
  exit 0
elif [ &quot;$COMMAND&quot; = &quot;pe&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.PerformanceEvaluation&#x27;
  HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_PE_OPTS&quot;
elif [ &quot;$COMMAND&quot; = &quot;ltt&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.util.LoadTestTool&#x27;
  HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_LTT_OPTS&quot;
elif [ &quot;$COMMAND&quot; = &quot;canary&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.tool.CanaryTool&#x27;
  HBASE_OPTS=&quot;$HBASE_OPTS $HBASE_CANARY_OPTS&quot;
elif [ &quot;$COMMAND&quot; = &quot;version&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.util.VersionInfo&#x27;
elif [ &quot;$COMMAND&quot; = &quot;regionsplitter&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.util.RegionSplitter&#x27;
elif [ &quot;$COMMAND&quot; = &quot;rowcounter&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.mapreduce.RowCounter&#x27;
elif [ &quot;$COMMAND&quot; = &quot;cellcounter&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.mapreduce.CellCounter&#x27;
elif [ &quot;$COMMAND&quot; = &quot;pre-upgrade&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.tool.PreUpgradeValidator&#x27;
elif [ &quot;$COMMAND&quot; = &quot;completebulkload&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.tool.BulkLoadHFilesTool&#x27;
elif [ &quot;$COMMAND&quot; = &quot;hbtop&quot; ] ; then
  CLASS=&#x27;org.apache.hadoop.hbase.hbtop.HBTop&#x27;
  if [ -n &quot;$&#123;shaded_jar&#125;&quot; ] ; then
    for f in &quot;$&#123;HBASE_HOME&#125;&quot;/lib/hbase-hbtop*.jar; do
      if [ -f &quot;$&#123;f&#125;&quot; ]; then
        CLASSPATH=&quot;$&#123;CLASSPATH&#125;:$&#123;f&#125;&quot;
        break
      fi
    done
    for f in &quot;$&#123;HBASE_HOME&#125;&quot;/lib/commons-lang3*.jar; do
      if [ -f &quot;$&#123;f&#125;&quot; ]; then
        CLASSPATH=&quot;$&#123;CLASSPATH&#125;:$&#123;f&#125;&quot;
        break
      fi
    done
  fi

  if [ -f &quot;$&#123;HBASE_HOME&#125;/conf/log4j-hbtop.properties&quot; ] ; then
    HBASE_HBTOP_OPTS=&quot;$&#123;HBASE_HBTOP_OPTS&#125; -Dlog4j.configuration=file:$&#123;HBASE_HOME&#125;/conf/log4j-hbtop.properties&quot;
  fi
  HBASE_OPTS=&quot;$&#123;HBASE_OPTS&#125; $&#123;HBASE_HBTOP_OPTS&#125;&quot;
else
  CLASS=$COMMAND
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">Have JVM dump heap <span class="hljs-keyword">if</span> we run out of memory.  Files will be <span class="hljs-string">&#x27;launch directory&#x27;</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">and are named like the following: java_pid21612.hprof. Apparently it doesn<span class="hljs-string">&#x27;t</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&#x27;</span>cost<span class="hljs-string">&#x27; to have this flag enabled. Its a 1.6 flag only. See:</span></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">http://blogs.sun.com/alanb/entry/outofmemoryerror_looks_a_bit_better</span></span>
HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.log.dir=$HBASE_LOG_DIR&quot;
HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.log.file=$HBASE_LOGFILE&quot;
HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.home.dir=$HBASE_HOME&quot;
HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.id.str=$HBASE_IDENT_STRING&quot;
HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.root.logger=$&#123;HBASE_ROOT_LOGGER:-INFO,console&#125;&quot;
if [ &quot;x$JAVA_LIBRARY_PATH&quot; != &quot;x&quot; ]; then
  HBASE_OPTS=&quot;$HBASE_OPTS -Djava.library.path=$JAVA_LIBRARY_PATH&quot;
  export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:$JAVA_LIBRARY_PATH&quot;
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">仅在 master 和 regionserver 上启用安全日志记录</span></span>
if [ &quot;$COMMAND&quot; = &quot;master&quot; ] || [ &quot;$COMMAND&quot; = &quot;regionserver&quot; ]; then
  HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.security.logger=$&#123;HBASE_SECURITY_LOGGER:-INFO,RFAS&#125;&quot;
else
  HBASE_OPTS=&quot;$HBASE_OPTS -Dhbase.security.logger=$&#123;HBASE_SECURITY_LOGGER:-INFO,NullAppender&#125;&quot;
fi

HEAP_SETTINGS=&quot;$JAVA_HEAP_MAX $JAVA_OFFHEAP_MAX&quot;
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">现在，如果我们正在运行命令，则意味着我们需要记录</span></span>
for f in $&#123;HBASE_HOME&#125;/lib/client-facing-thirdparty/slf4j-log4j*.jar; do
  if [ -f &quot;$&#123;f&#125;&quot; ]; then
    CLASSPATH=&quot;$&#123;CLASSPATH&#125;:$&#123;f&#125;&quot;
    break
  fi
done
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">除非设置了 HBASE_NOEXEC，否则执行</span></span>
export CLASSPATH
if [ &quot;$&#123;DEBUG&#125;&quot; = &quot;true&quot; ]; then
  echo &quot;classpath=$&#123;CLASSPATH&#125;&quot; &gt;&amp;2
  HBASE_OPTS=&quot;$&#123;HBASE_OPTS&#125; -Xdiag&quot;
fi

if [ &quot;$&#123;HBASE_NOEXEC&#125;&quot; != &quot;&quot; ]; then
  &quot;$JAVA&quot; -Dproc_$COMMAND -XX:OnOutOfMemoryError=&quot;kill -9 %p&quot; $HEAP_SETTINGS $HBASE_OPTS $CLASS &quot;$@&quot;
else
  export JVM_PID=&quot;$$&quot;
  exec &quot;$JAVA&quot; -Dproc_$COMMAND -XX:OnOutOfMemoryError=&quot;kill -9 %p&quot; $HEAP_SETTINGS $HBASE_OPTS $CLASS &quot;$@&quot;
fi</code></pre></div><hr><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><h3 id="stop-hbase-sh"><a href="#stop-hbase-sh" class="headerlink" title="stop-hbase.sh"></a>stop-hbase.sh</h3><p>停止 hadoop hbase 守护程序，在主节点上运行以停止整个 HBase 服务。</p><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">仿照 <span class="hljs-variable">$HADOOP_HOME</span>/bin/stop-hbase.sh.</span>

bin=`dirname &quot;$&#123;BASH_SOURCE-$0&#125;&quot;`
bin=`cd &quot;$bin&quot;&gt;/dev/null; pwd`
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">加载环境变量和参数</span>
. &quot;$bin&quot;/hbase-config.sh
. &quot;$bin&quot;/hbase-common.sh
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">停止命令需要的一些参数</span>
if [ &quot;$HBASE_LOG_DIR&quot; = &quot;&quot; ]; then
  export HBASE_LOG_DIR=&quot;$HBASE_HOME/logs&quot;
fi
mkdir -p &quot;$HBASE_LOG_DIR&quot;

if [ &quot;$HBASE_IDENT_STRING&quot; = &quot;&quot; ]; then
  export HBASE_IDENT_STRING=&quot;$USER&quot;
fi

export HBASE_LOG_PREFIX=hbase-$HBASE_IDENT_STRING-master-$HOSTNAME
export HBASE_LOGFILE=$HBASE_LOG_PREFIX.log
logout=$HBASE_LOG_DIR/$HBASE_LOG_PREFIX.out  
loglog=&quot;$&#123;HBASE_LOG_DIR&#125;/$&#123;HBASE_LOGFILE&#125;&quot;
pid=$&#123;HBASE_PID_DIR:-/tmp&#125;/hbase-$HBASE_IDENT_STRING-master.pid
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">如果 HBase 的相关进程号文件存在，则调用 <span class="hljs-string">&quot;<span class="hljs-variable">$HBASE_HOME</span>&quot;</span>/bin/hbase 停止服务，并记录日志，停止后删除进程号文件，见附 4</span>
if [[ -e $pid ]]; then
  echo -n stopping hbase
  echo &quot;`date` Stopping hbase (via master)&quot; &gt;&gt; $loglog

  nohup nice -n $&#123;HBASE_NICENESS:-0&#125; &quot;$HBASE_HOME&quot;/bin/hbase \
     --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; \
     master stop &quot;$@&quot; &gt; &quot;$logout&quot; 2&gt;&amp;1 &lt; /dev/null &amp;

  waitForProcessEnd `cat $pid` &#x27;stop-master-command&#x27;

  rm -f $pid
else
  echo no hbase master found
fi
<span class="hljs-meta prompt_"></span>
<span class="hljs-meta prompt_"># </span><span class="language-bash">单机模式下停止由 HBase 管理的 Zookeeper 服务，即 HQuorumPeer 进程</span>
distMode=`$bin/hbase --config &quot;$HBASE_CONF_DIR&quot; org.apache.hadoop.hbase.util.HBaseConfTool hbase.cluster.distributed | head -n 1`
if [ &quot;$distMode&quot; == &#x27;true&#x27; ] 
then
  &quot;$bin&quot;/hbase-daemons.sh --config &quot;$&#123;HBASE_CONF_DIR&#125;&quot; stop zookeeper
fi</code></pre></div><h4 id="附-4"><a href="#附-4" class="headerlink" title="附 4"></a>附 4</h4><p><code>$bin/hbase</code>接收到 master stop 参数，并经过脚本识别后调用 HMaster 类，进行停止。省略了从 HMaster 到 HMasterCommandLine 的传参过程，前文已经描述过，这里直接从 HMasterCommandLine 中的 stopMaster 方法开始分析。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HMasterCommandLine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServerCommandLine</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception &#123;
        ……
        
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;start&quot;</span>.equals(command)) &#123;
          <span class="hljs-keyword">return</span> startMaster();
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;stop&quot;</span>.equals(command)) &#123;
          <span class="hljs-comment">// 匹配到 stop 的指令</span>
          <span class="hljs-keyword">return</span> stopMaster();
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;clear&quot;</span>.equals(command)) &#123;
          <span class="hljs-keyword">return</span> (ZNodeClearer.clear(getConf()) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);
        &#125; <span class="hljs-keyword">else</span> &#123;
          usage(<span class="hljs-string">&quot;Invalid command: &quot;</span> + command);
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125;
    &#125;
    
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">stopMaster</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// 获取配置文件</span>
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> getConf();
        <span class="hljs-comment">// 客户端请求失败不再重试</span>
        conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, <span class="hljs-number">0</span>);
        <span class="hljs-comment">// 此处 createConnection 方法通过反射获取一个新的 connection 实例</span>
        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionFactory.createConnection(conf)) &#123;
          <span class="hljs-comment">// 再经过 connection 获得 Admin 实例，Admin 是 HBase 用来管理的 API</span>
          <span class="hljs-keyword">try</span> (<span class="hljs-type">Admin</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> connection.getAdmin()) &#123;
            admin.shutdown();
          &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
            LOG.error(<span class="hljs-string">&quot;Failed to stop master&quot;</span>, t);
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
          &#125;
        &#125; <span class="hljs-keyword">catch</span> (MasterNotRunningException e) &#123;
          LOG.error(<span class="hljs-string">&quot;Master not running&quot;</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">catch</span> (ZooKeeperConnectionException e) &#123;
          LOG.error(<span class="hljs-string">&quot;ZooKeeper not available&quot;</span>);
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
          LOG.error(<span class="hljs-string">&quot;Got IOException: &quot;</span> +e.getMessage(), e);
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-comment">// 只有当正确停止后，返回 0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre></div><p>源码中看到 shutdown 方法和 ShutdownRequest 类等等都是报红的，这是因为 HBase 的某些类和方法是由 protobuf 之类的工具生成的。变量 master 是接口 MasterKeepAliveConnection 的实例，该接口有两个实现类：在 ConnectionImplementation 类中 getKeepAliveMasterService 方法直接返回的内部类 MasterKeepAliveConnection 以及 ShortCircuitMasterConnection。ShortCircuitMasterConnection 是与本地主机通信时可以绕过RPC层（串行化，反序列化，网络等）的短路连接类。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HBaseAdmin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Admin</span> &#123;
    <span class="hljs-keyword">protected</span> MasterKeepAliveConnection master;
    ……
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;
        executeCallable(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MasterCallable</span>&lt;Void&gt;(getConnection(), getRpcControllerFactory()) &#123;
          <span class="hljs-meta">@Override</span>
          <span class="hljs-keyword">protected</span> Void <span class="hljs-title function_">rpcCall</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;
            <span class="hljs-comment">// 设置请求的优先级为高优先级</span>
            setPriority(HConstants.HIGH_QOS);
            master.shutdown(getRpcController(), ShutdownRequest.newBuilder().build());
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          &#125;
        &#125;);
      &#125;
&#125;</code></pre></div><p>这里调用分析的是 getKeepAliveMasterService 方法返回的内部类，ShortCircuitMasterConnection 类中的 shutdown 方法也是类似的，通过 MasterProtos 最终调用至实现了 MasterService.BlockingInterface 接口的 MasterRpcServices 类。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionImplementation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClusterConnection</span>, Closeable &#123;
    ……
    
    <span class="hljs-keyword">private</span> MasterKeepAliveConnection <span class="hljs-title function_">getKeepAliveMasterService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;
        ……
        <span class="hljs-comment">// Ugly delegation just so we can add in a Close method.</span>
        <span class="hljs-keyword">final</span> MasterProtos.MasterService.<span class="hljs-type">BlockingInterface</span> <span class="hljs-variable">stub</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.masterServiceState.stub;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MasterKeepAliveConnection</span>() &#123;
          <span class="hljs-type">MasterServiceState</span> <span class="hljs-variable">mss</span> <span class="hljs-operator">=</span> masterServiceState;
          ……
          
          <span class="hljs-meta">@Override</span>
          <span class="hljs-keyword">public</span> MasterProtos.ShutdownResponse <span class="hljs-title function_">shutdown</span><span class="hljs-params">(RpcController controller,</span>
<span class="hljs-params">              MasterProtos.ShutdownRequest request)</span> <span class="hljs-keyword">throws</span> ServiceException &#123;
            <span class="hljs-keyword">return</span> stub.shutdown(controller, request);
          &#125;
        &#125;  
    &#125;
&#125;</code></pre></div><p>可以看到，在 MasterRpcServices 中，通过实例化的 HMaster 对象，调用的是 shutdown 方法来进行停止。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MasterRpcServices</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RSRpcServices</span>
      <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MasterService</span>.BlockingInterface, RegionServerStatusService.BlockingInterface,
        LockService.BlockingInterface, HbckService.BlockingInterface &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HMaster master;
    ……
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ShutdownResponse <span class="hljs-title function_">shutdown</span><span class="hljs-params">(RpcController controller,</span>
<span class="hljs-params">          ShutdownRequest request)</span> <span class="hljs-keyword">throws</span> ServiceException &#123;
        LOG.info(master.getClientIdAuditPrefix() + <span class="hljs-string">&quot; shutdown&quot;</span>);
        <span class="hljs-keyword">try</span> &#123;
          master.shutdown();
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
          LOG.error(<span class="hljs-string">&quot;Exception occurred in HMaster.shutdown()&quot;</span>, e);
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(e);
        &#125;
        <span class="hljs-keyword">return</span> ShutdownResponse.newBuilder().build();
      &#125;
&#125;</code></pre></div><p>HMaster 会先停止所有的 HRegionServer 服务，然后再停止自身。将 ServerManager 的状态设置为关闭后，RegionServer 将注意到状态的变化，并开始自行关闭，等最后一个 RegionServer 退出后，HMaster 即可关闭。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HMaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HRegionServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MasterServices</span> &#123;
    ……
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;
        <span class="hljs-keyword">if</span> (cpHost != <span class="hljs-literal">null</span>) &#123;
          cpHost.preShutdown();
        &#125;
    
        <span class="hljs-comment">// 告知 serverManager 关闭集群，serverManager 是用于管理 RegionServer 的</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.serverManager != <span class="hljs-literal">null</span>) &#123;
          <span class="hljs-built_in">this</span>.serverManager.shutdownCluster();
        &#125;
        <span class="hljs-comment">// clusterStatusTracker 是用于在 Zookeeper 中对集群设置进行追踪的，这里通过删除 znode 来达到关闭集群的目的</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.clusterStatusTracker != <span class="hljs-literal">null</span>) &#123;
          <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-built_in">this</span>.clusterStatusTracker.setClusterDown();
          &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;
            LOG.error(<span class="hljs-string">&quot;ZooKeeper exception trying to set cluster as down in ZK&quot;</span>, e);
          &#125;
        &#125;
        <span class="hljs-comment">// Stop the procedure executor. Will stop any ongoing assign, unassign, server crash etc.,</span>
        <span class="hljs-comment">// processing so we can go down.</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.procedureExecutor != <span class="hljs-literal">null</span>) &#123;
          <span class="hljs-built_in">this</span>.procedureExecutor.stop();
        &#125;
        <span class="hljs-comment">// 关闭集群联机，将杀死可能正在运行的 RPC，如果不关闭连接，将不得不等待 RPC 超时</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.clusterConnection != <span class="hljs-literal">null</span>) &#123;
          <span class="hljs-built_in">this</span>.clusterConnection.close();
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(String msg)</span> &#123;
        <span class="hljs-comment">// isStopped 方法继承自 HRegionServer，在其停止后会设置为 false</span>
        <span class="hljs-keyword">if</span> (!isStopped()) &#123;
          <span class="hljs-comment">// 调用父类 HRegionServer 的 stop 方法挨个进行停止</span>
          <span class="hljs-built_in">super</span>.stop(msg);
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.activeMasterManager != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-built_in">this</span>.activeMasterManager.stop();
          &#125;
        &#125;
    &#125;
&#125;</code></pre></div><p>接上文，在 ServerManager 中调用 shutdownCluster 方法后又回到 HMaster 中，调用其自身的 stop 方法进行停止。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerManager</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MasterServices master;
    ……
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdownCluster</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">String</span> <span class="hljs-variable">statusStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Cluster shutdown requested of master=&quot;</span> + <span class="hljs-built_in">this</span>.master.getServerName();
        LOG.info(statusStr);
        <span class="hljs-comment">// 设置集群关闭状态</span>
        <span class="hljs-built_in">this</span>.clusterShutdown.set(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">if</span> (onlineServers.isEmpty()) &#123;
          <span class="hljs-comment">// 这里没有使用同步方法可能会导致停止两次，但这没啥问题</span>
          master.stop(<span class="hljs-string">&quot;OnlineServer=0 right after cluster shutdown set&quot;</span>);
        &#125;
      &#125;
&#125;</code></pre></div><p>HRegionServer 在接收到子类 HMaster 的 stop 方法调用后，开始停止服务。其 run 方法在开始运行时一直处于自旋状态，将 stopped 变量改为 true 后，会运行后面部分的代码，即停止相关服务。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HRegionServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HasThread</span> <span class="hljs-keyword">implements</span>
    <span class="hljs-title class_">RegionServerServices</span>, LastSequenceId, ConfigurationObserver &#123;
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stopped</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
    ……
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String msg)</span> &#123;
        stop(msg, <span class="hljs-literal">false</span>, RpcServer.getRequestUser().orElse(<span class="hljs-literal">null</span>));
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String msg, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> force, <span class="hljs-keyword">final</span> User user)</span> &#123;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.stopped) &#123;
          LOG.info(<span class="hljs-string">&quot;***** STOPPING region server &#x27;&quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot;&#x27; *****&quot;</span>);
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.rsHost != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-comment">// when forced via abort don&#x27;t allow CPs to override</span>
            <span class="hljs-keyword">try</span> &#123;
              <span class="hljs-built_in">this</span>.rsHost.preStop(msg, user);
            &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;
              <span class="hljs-keyword">if</span> (!force) &#123;
                LOG.warn(<span class="hljs-string">&quot;The region server did not stop&quot;</span>, ioe);
                <span class="hljs-keyword">return</span>;
              &#125;
              LOG.warn(<span class="hljs-string">&quot;Skipping coprocessor exception on preStop() due to forced shutdown&quot;</span>, ioe);
            &#125;
          &#125;
          <span class="hljs-built_in">this</span>.stopped = <span class="hljs-literal">true</span>;
          LOG.info(<span class="hljs-string">&quot;STOPPED: &quot;</span> + msg);
          <span class="hljs-comment">// Wakes run() if it is sleeping</span>
          sleeper.skipSleepCycle();
        &#125;
      &#125;
&#125;</code></pre></div><p>省略了后续相关服务停止以及 Zookeeper 清理等部分，至此，整个 HMaster 集群已经完全关闭。</p><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="hbase-env-sh"><a href="#hbase-env-sh" class="headerlink" title="hbase-env.sh"></a>hbase-env.sh</h3><p>前面的一些脚本中有加载 hbase-env.sh 中的环境变量，这些变量都是给用户提供的可配置项。<br>它设置了 HBase 运行中的一些重要 JVM 参数，在对 HBase 进行调优时可能会用到。</p><p>文件格式是以<code>export 环境变量名=变量值</code>这种形式组织的</p><ul><li><p><code>JAVA_HOME</code> - JDK 路径，Java 1.8+</p></li><li><p><code>HBASE_CLASSPATH</code> - 额外的 Java CLASSPATH，可选项</p></li><li><p><code>HBASE_HEAPSIZE</code> - 使用的最大堆数量，默认为 JVM 默认值</p></li><li><p><code>HBASE_OFFHEAPSIZE</code> - 堆外内存</p></li><li><p><code>HBASE_OPTS</code> - 额外的 Java 运行时参数，默认为”-XX:+UseConcMarkSweepGC”，使用 CMS 收集器对年老代进行垃圾收集，CMS 收集器通过多线程并发进行垃圾回收，尽量减少垃圾收集造成的停顿</p></li><li><p><code>SERVER_GC_OPTS</code> - 可以为服务器端进程启用 Java 垃圾回收日志记录</p></li><li><p><code>CLIENT_GC_OPTS</code> - 为客户端进程启用Java垃圾回收日志记录</p></li><li><p>额外的运行时选项配置，包含 JMX 导出、启用主要 HBase 进程的远程 JDWP 调试等</p><ul><li><code>HBASE_JMX_BASE</code></li><li><code>HBASE_MASTER_OPTS</code></li><li><code>HBASE_REGIONSERVER_OPTS</code></li><li><code>HBASE_THRIFT_OPTS</code></li><li><code>HBASE_ZOOKEEPER_OPTS</code></li></ul></li><li><p><code>HBASE_REGIONSERVERS</code> - RegionServer 服务运行节点</p></li><li><p><code>HBASE_REGIONSERVER_MLOCK</code> - 是否使所有区域服务器页面都映射为驻留在内存中</p></li><li><p><code>HBASE_REGIONSERVER_UID</code> - RegionServer 的用户 ID</p></li><li><p><code>HBASE_BACKUP_MASTERS</code> - 备用 Master 节点</p></li><li><p><code>HBASE_SSH_OPTS</code> - 额外的 ssh 选项</p></li><li><p><code>HBASE_LOG_DIR</code> - HBase 日志存储路径</p></li><li><p><code>HBASE_IDENT_STRING</code> - 标识 HBase 实例的字符串，默认为当前用户</p></li><li><p><code>HBASE_NICENESS</code> - 守护进程的调度优先级</p></li><li><p><code>HBASE_PID_DIR</code> - PID 文件的存储路径，默认是 /tmp，最好换个稳定的路径</p></li><li><p><code>HBASE_SLAVE_SLEEP</code> - 在从属命令之间休眠的秒数，默认情况下未设置</p></li><li><p><code>HBASE_MANAGES_ZK</code> - 是否启动 HBase 内嵌的 Zookeeper，一般使用集群的 Zookeeper</p></li><li><p><code>HBASE_ROOT_LOGGER</code> - HBase 日志级别</p></li><li><p><code>HBASE_DISABLE_HADOOP_CLASSPATH_LOOKUP</code> - HBase 启动时是否应包含 Hadoop 的库，默认值为 false，表示包含 Hadoop 的库</p></li></ul><h3 id="hbase-site-xml"><a href="#hbase-site-xml" class="headerlink" title="hbase-site.xml"></a>hbase-site.xml</h3><p>该文件配置项较多，此处仅列举一些常见集群配置项，更多参数请移步<a target="_blank" rel="noopener" href="https://hbase.apache.org/book.html#config.files">官方文档</a>。<br>文件格式是以下面这种形式组织的：</p><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>参数名称<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>参数值<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre></div><ul><li><p><code>hbase.tmp.dir</code> - 本地文件系统上的临时目录，默认为 /tmp/hbase-${user.name}，最好更改此路径为一个更稳定的，否则数据容易丢失。</p></li><li><p><code>hbase.rootdir</code> - RegionServers 共享目录，也是 HBase 持久化存储的目录，支持 HDFS 的存储。默认情况下写到 ${hbase.tmp.dir}/hbase 目录，所以最好更改此目录，否则机器重新启动后，所有的数据将丢失。</p></li><li><p><code>hbase.cluster.distributed</code> - 集群启动模式，单机模式为 false（默认值），集群模式为 true。如果为 false，将在同一个 JVM 中运行 HBase 以及 Zookeeper 的进程。</p></li><li><p><code>hbase.zookeeper.quorum</code> - Zookeeper 服务器列表，以逗号分隔，默认是 127.0.0.1。如果在 hbase-env.sh 中配置了<code>export HBASE_MANAGES_ZK=true</code>，那么该 Zookeeper服务将由 HBase 进行管理，作为 HBase 启动/停止的一部分，最好是部署独立的 Zookeeper 集群。</p></li><li><p><code>hbase.zookeeper.property.dataDir</code> - Zookeeper 配置文件 zoo.cfg 中的属性，也是快照存储的目录，只有在使用外置的 Zookeeper 集群服务时有效。</p></li><li><p><code>hbase.master.port</code> - Master 的内部端口号，默认是 16000。</p></li><li><p><code>hbase.master.info.port</code> - Master 的 Web UI 端口号，默认是 16010，如果不想运行 UI 实例，设置为 -1 即可。</p></li><li><p><code>hbase.regionserver.port</code> - RegionServer 的内部端口号，默认是 16020。</p></li><li><p><code>hbase.regionserver.info.port</code> - RegionServer 的 Web UI 端口号，默认是 16030，如果不想运行 UI 实例，设置为 -1 即可。</p></li><li><p><code>hbase.regionserver.handler.count</code> - 在 RegionServer 上的 RPC 监听器实例计数，Master 也使用相同的属性，太多的 handlers 可能会适得其反。将其设置为 CPU 的倍数，如果大多数情况下是只读的，那么接近 CPU 数更好，从 CPU 数的两倍开始进行调整，默认为 30。</p></li><li><p><code>hbase.regionserver.global.memstore.size</code> - 在阻止新的更新并强制刷新之前，RegionServer 中所有内存的最大值，默认为堆的 0.4。更新被阻塞并强制刷新，知道一个 RegionServer 中所有内存的大小达到 hbase.regionserver.global.memstore.size.lower.limit，配置中的默认值保留为空。</p></li><li><p><code>hbase.regionserver.global.memstore.size.lower.limit</code> - 默认是 hbase.regionserver.global.memstore.size 的 95%，配置中的默认值保留为空。</p></li><li><p><code>zookeeper.znode.parent</code> - Zookeeper 中 HBase 的根 Znode 节点，默认是 /hbase。</p></li><li><p><code>dfs.client.read.shortcircuit</code> - 设置为 true，则启用本地短路读，默认是 false。</p></li><li><p><code>hbase.column.max.version</code> - 新的列簇将使用此值作为默认的版本数，默认是 1。</p></li><li><p><code>hbase.coprocessor.master.classes</code> - 以逗号分隔的协处理器列表，在 HMaster 上加载的 MasterObserver 协处理器，指定完整的类名。</p></li><li><p><code>hbase.coprocessor.region.classes</code> - 以逗号分隔的协处理器列表，在所有的表上加载，指定完整的类名，也可通过 HTableDescriptor 或 HBase shell 按需加载。</p></li><li><p><code>hbase.coprocessor.user.region.classes</code> - 从配置中加载用户表的系统默认协处理器，用户可以继承 HBase 的 RegionCoprocessor 实现自己需要的逻辑部分，指定完整的类名。</p></li><li><p><code>hbase.coprocessor.user.enabled</code> - 启用/禁用加载用户的协处理器加载，默认为 true。</p></li><li><p><code>hbase.coprocessor.enabled</code> - 启用/禁用加载所有的协处理器加载，默认为 true。</p></li></ul></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a> <a class="hover-with-bg" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/">分布式存储</a> <a class="hover-with-bg" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/HBase/">HBase</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/HBase/">HBase</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2021/03/29/Spark-RPC/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Spark RPC</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2021/03/17/Spark%E6%A6%82%E8%BF%B0/"><span class="hidden-mobile">Spark 概述</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",(function(){new Valine({el:"#valine",app_id:"gffo4y4h3e1D9tHT2ADcTxtp-gzGzoHsz",app_key:"EaplHXnXAqIYs5wCxGMVB4l4",placeholder:"说点什么",path:window.location.pathname,avatar:"robohash",meta:["nick","mail"],pageSize:"10",lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:""})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><script src="/js/boot.js"></script></body></html>