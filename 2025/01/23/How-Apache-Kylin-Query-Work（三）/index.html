<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="Guoliang"><meta name="keywords" content=""><title>How Apache Kylin Query Work（三） - Guoliang&#39;s Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/a11y-dark.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.10",typing:{enable:!0,typeSpeed:80,cursorChar:"乄",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"always",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"gffo4y4h3e1D9tHT2ADcTxtp-gzGzoHsz",app_key:"EaplHXnXAqIYs5wCxGMVB4l4",server_url:"https://gffo4y4h.lc-cn-n1-shared.com"}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>步尽白</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/pingan.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="How Apache Kylin Query Work（三）"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Guoliang </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-01-23 16:36" pubdate>2025年1月23日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 13 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">How Apache Kylin Query Work（三）</h1><p class="note note-info">本文最后更新于：2025年1月23日 下午</p><div class="markdown-body"><h1 id="FYI"><a href="#FYI" class="headerlink" title="FYI"></a>FYI</h1><ul><li>repo：<a target="_blank" rel="noopener" href="https://github.com/apache/kylin">https://github.com/apache/kylin</a></li><li>branch：kylin5</li><li>commitMessage：Merge pull request #2245 from VaitaR/patch-1</li><li>commitID：e18b73ab6a6ed66de41532bc03373e8efeff0b77</li></ul><h1 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h1><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ul><li><p><strong>Table</strong> - 源数据表。在创建模型并加载数据之前，系统需要从数据源（通常为 Hive）同步表的元数据，包含表名、列名、列属性等。</p></li><li><p><strong>Model</strong> - 模型，也是逻辑语义层。模型是一组表以及它们间的关联关系 (Join Relationship)。模型中定义了事实表、维度表、度量、维度、和一组索引。模型和其中的索引定义了加载数据时要执行的预计算。系统支持基于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%98%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B/9133897">星型模型</a> 和 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9B%AA%E8%8A%B1%E6%A8%A1%E5%9E%8B">雪花模型</a> 的多维模型。</p></li><li><p><strong>Index</strong> - 索引，在数据加载时将构建索引，索引将被用于加速查询。索引分为聚合索引与明细索引。</p><ul><li><strong>Aggregate Index</strong> - 聚合索引，本质是多个维度和度量的组合，适合回答聚合查询，比如某年的销售总额。</li><li><strong>Table Index</strong> - 明细索引，本质是大宽表的多路索引，适合回答精确到记录的明细查询，比如某用户最近 100 笔交易。</li></ul></li><li><p><strong>Load Data</strong> - 加载数据。为了加速查询，需要将数据从源表加载入模型，在此过程中也将构建索引，整个过程即是数据的预计算过程。每一次数据加载将产生一个 Segment，载入数据后的模型可以服务于查询。</p><ul><li><strong>Incremental Load</strong> - 增量数据加载。在事实表上可以定义一个分区日期或时间列。根据分区列，可以按时间范围对超大数据集做增量加载。</li><li><strong>Full Load</strong> - 全量加载。如果没有定义分区列，那么源表中的所有数据将被一次性加载。</li><li><strong>Build Index</strong> - 重建索引。用户可以随时调整模型和索引的定义。对于已加载的数据，其上的索引需要按新的定义重新构建。</li></ul></li><li><p><strong>Segments</strong> - 数据块。是模型（索引组）经过数据加载后形成的数据块。Segment 的生成以分区列为依据。对于有分区列的模型（索引组），可以拥有一个或多个 Segment，对于没有分区列的模型（索引组），只能拥有一个 Segment。</p></li></ul><h2 id="OlapContext"><a href="#OlapContext" class="headerlink" title="OlapContext"></a>OlapContext</h2><p>SQL 进入 Kylin 中经过 Calcite 解析转换、优化后形成一棵树结构的查询逻辑计划 RelNode，这种结构是 Calcite 在逻辑层的一种表示，比较典型的 RelNode 树结构如下图 case1 所示。<br>如果再加上 RelNode 的详细信息，绝大多数场景下可以将这棵树重新翻译成原始 SQL，但这种结构无法直接作用于 Kylin 的预计算，因此 Kylin 定义了一种可以预计算的数据结构，这种结构称之为 OlapContext，它能够同时对应 RelNode 和 Kylin 匹配的模型索引。</p><p><img src="https://cdn.jsdelivr.net/gh/gleonSun/images@main/image/202408221026607.png" srcset="/img/loading.gif" lazyload></p><p>需重点关注的属性</p><ul><li><strong><code>firstTableScan</code></strong>: OlapContext 用到的第一张表（通常指事实表）</li><li><strong><code>allTableScans</code></strong>: 使用到的所有表信息</li><li><strong><code>aggregations</code></strong>: 查询的度量算子</li><li><strong><code>filterColumns</code></strong>: 过滤条件（SQL where 条件的列或者表达式）</li><li><strong><code>joins</code></strong>: 表与表的 join 关系</li><li><strong><code>sql</code></strong>: 生成 OlapContext 的原始 SQL，一条 SQL 可能会被切分成多个 OlapContext</li><li><strong><code>topNode</code></strong>: OlapContext 最顶端的 RelNode 节点</li><li><strong><code>expandedFilterConditions</code></strong>: 记录查询用到的过滤表达式，以支持后面做过滤优化</li></ul><p>除此之外还有一些别的属性需要留意</p><ul><li><strong><code>parentOfTopNode</code></strong>: 一般为 null 除非 JoinRel 被切分开</li><li><strong><code>innerGroupByColumns、innerFilterColumns</code></strong>: 推荐可计算列时使用到</li><li><strong><code>sortColumns</code></strong>: 排序列</li></ul><p>总结一下，OlapContext 记录了整个 Kylin 模型匹配的上下文信息，是最核心的数据结构，对这块熟悉可以更好地理解索引匹配流程。</p><h2 id="OlapRel"><a href="#OlapRel" class="headerlink" title="OlapRel"></a>OlapRel</h2><p>Kylin 继承自 Calcite 实现的抽象接口类，定义了遍历整个查询阶段所需上下文及遍历方式，需关注的属性和方法</p><ul><li><strong><code>getColumnRowType</code></strong>: 记录了原始表类型和 Kylin 模型中列数据类型的对应关系</li><li><strong><code>implementOlap</code></strong>: 子类需实现的遍历方法，包含建立和原始表的对应关系，收集 OlapContext 的信息都会在这个方法中完成，是很重要的方法</li><li><strong><code>implementRewrite</code></strong>: 在完成模型匹配之后，基于情况对查询逻辑计划树进行重建</li><li><strong><code>implementEnumerable</code></strong>: 适配 Calcite EnumerableConvention 物理执行引擎的 Java 实现</li><li><strong><code>implementContext</code></strong>: 分配 OlapContext 的逻辑方法，一个完整的查询逻辑计划可能会划分成多个 OlapContext</li><li><strong><code>implementCutContext</code></strong>: 如果 OlapContext 切分得太大无法匹配模型索引，则会尝试对其再次切分</li></ul><hr><h2 id="Model-Match"><a href="#Model-Match" class="headerlink" title="Model Match"></a>Model Match</h2><p>入口: <strong><span class="label label-primary">QueryContextCutter#selectRealization</span></strong></p><p>整体流程图<br><img src="https://cdn.jsdelivr.net/gh/gleonSun/images@main/image/KylinModelMatch-1737621343603.png" srcset="/img/loading.gif" lazyload></p><h3 id="1-Divide-OlapContext"><a href="#1-Divide-OlapContext" class="headerlink" title="1. Divide OlapContext"></a>1. Divide OlapContext</h3><p>OlapContext 的划分和分配在选出最优的查询逻辑计划之后，匹配模型索引之前。</p><p>一个基本的规则是遇到 agg 就划分出一个 OlapContext，如 OlapContext 示例图的 case1，从 agg 往下遍历时没有其他的 agg，当前查询逻辑计划树就只会分配一个 OlapContext，同理，case2 和 case3 会划分出两个 OlapContext。</p><p>每个 OlapContext 代表着模型索引的最小匹配单元，在划分后，将 OlapContext 与模型索引进行匹配，当无法匹配时，会将大的 OlapContext 再次切分成小的进行匹配，直到达到最大尝试切分的匹配次数，默认是 10，可通过项目级参数进行配置。</p><p>划分 OlapContext 主要通过下面两个类</p><ul><li><p><strong><code>ContextInitialCutStrategy</code></strong></p><ul><li>遍历查询逻辑计划树，接着通过子类实现的 <strong><code>OlapRel#implementContext</code></strong> 方法划分 OlapContext</li><li>如果还有未分配的表，会为其直接分配 OlapContext</li></ul></li><li><p><strong><code>ContextReCutStrategy</code></strong></p><ul><li>主要逻辑是将大的 OlapContext 切小尽可能匹配模型索引，接着通过子类实现的 <strong><code>OlapRel#implementCutContext</code></strong> 方法划分 OlapContext</li></ul></li></ul><p>划分逻辑相对复杂的子类是 OlapJoinRel，先访问 leftChild，再访问 rightChild，最后在当前节点上分配 OlapContext。</p><h3 id="2-Fill-OlapContext"><a href="#2-Fill-OlapContext" class="headerlink" title="2. Fill OlapContext"></a>2. Fill OlapContext</h3><p>通过后序遍历的方式对先前压入栈的查询逻辑计划节点填充 OlapContext 信息，上面第一段逻辑是基于查询逻辑计划切分出 OlapContext，然而还需要在查询节点上收集必要的 OlapContext 信息，通过每个子类实现的 <strong><code>OlapRel#implementOlap</code></strong> 方法进行填充。</p><h3 id="3-Choose-Candidate"><a href="#3-Choose-Candidate" class="headerlink" title="3. Choose Candidate"></a>3. Choose Candidate</h3><p>默认通过多线程的方式来选择匹配合适的索引，使用 CountDownLatch，输入是 Context 划分的数量。也可以通过项目级参数配置不使用多线程的方式匹配索引，串行执行。</p><h4 id="3-1-Attempt-Select-Candidate"><a href="#3-1-Attempt-Select-Candidate" class="headerlink" title="3.1 Attempt Select Candidate"></a>3.1 Attempt Select Candidate</h4><h5 id="3-1-1-Filter-qualified-models-by-firstTable-of-OlapContext"><a href="#3-1-1-Filter-qualified-models-by-firstTable-of-OlapContext" class="headerlink" title="3.1.1 Filter qualified models by firstTable of OlapContext"></a>3.1.1 Filter qualified models by firstTable of OlapContext</h5><p>基于 OlapContext 第一张表即事实表来筛选出待匹配的模型，每个 Project 都保存了对应的模型信息缓存在内存中，取出的操作是比较快的，取出后再过滤掉不符合条件的模型。</p><ul><li>移除没有准备好 Segments 的模型</li><li>用户通过 SQL hint 的方式指定了模型匹配的优先级，未指定的模型会被移除</li></ul><h5 id="3-1-2-Match-model"><a href="#3-1-2-Match-model" class="headerlink" title="3.1.2 Match model"></a>3.1.2 Match model</h5><p>先检查是否有待匹配模型，没有的话直接抛出异常，等待下次重试。模型匹配采用的是图匹配方式，参考类: <strong><code>JoinsGraph</code></strong></p><p>需关注属性</p><ul><li><strong><code>center</code></strong>: 表示图的中心表（通常是查询的主表），类型为 <code>TableRef</code>。</li><li><strong><code>vertexMap</code></strong>: 存储所有表的别名与表引用 <code>TableRef</code> 的映射关系，类型为 <code>Map&lt;String, TableRef&gt;</code>。</li><li><strong><code>vertexInfoMap</code></strong>: 存储每个表 <code>TableRef</code> 的顶点信息，包括该表的出边 <code>outEdges</code> 和入边 <code>inEdges</code>，类型为 <code>Map&lt;TableRef, VertexInfo&lt;Edge&gt;&gt;</code>。</li><li><strong><code>edges</code></strong>: 存储图中所有的边 <code>Edge</code>，类型为 <code>Set&lt;Edge&gt;</code>。<br>需关注方法</li><li><strong><code>match</code></strong>: 将当前图与一个模式图 <code>pattern</code> 进行匹配，返回是否匹配成功。匹配过程中会生成一个别名映射表 <code>matchAliasMap</code>，用于记录两个图中表的对应关系。</li><li><strong><code>match0</code></strong>: 匹配的核心逻辑，递归地匹配图中的表和边。</li><li><strong><code>findOutEdgeFromDualTable</code></strong>: 在模式图中查找与查询图匹配的边。</li><li><strong><code>normalize</code></strong>: 对图进行规范化处理，将某些左连接 <code>LEFT JOIN</code> 转换为左或内连接 <code>LEFT OR INNER JOIN</code> ，以便优化查询，需要通过额外的参数配置。</li></ul><h6 id="3-1-2-1-Try-to-exactly-match-model"><a href="#3-1-2-1-Try-to-exactly-match-model" class="headerlink" title="3.1.2.1 Try to exactly match model"></a>3.1.2.1 Try to exactly match model</h6><p>通过图匹配的方式对 OlapContext 中的事实表和join 关系与模型上的表和 join 关系等进行对比，检查其是否一一对应，如果都能匹配上，那么就可以说当前模型的索引是能够精确匹配查询 SQL 的。</p><p class="note note-info">OlapContex 中的表信息是从查询 SQL 的逻辑计划树中收集的。</p><h6 id="3-1-2-2-Try-to-partial-match-model"><a href="#3-1-2-2-Try-to-partial-match-model" class="headerlink" title="3.1.2.2 Try to partial match model"></a>3.1.2.2 Try to partial match model</h6><p>在精确匹配未找到合适模型的情况下，会基于配置参数再尝试部分匹配模型，这里的部分指的是仅匹配部分 join 关系。</p><h6 id="3-1-2-3-Lauout-Match-Select-Realizations"><a href="#3-1-2-3-Lauout-Match-Select-Realizations" class="headerlink" title="3.1.2.3 Lauout Match - Select Realizations"></a>3.1.2.3 Lauout Match - Select Realizations</h6><p>在已经选出合适的 layout 之后，会继续对候选的索引进行筛选，陆续应用以下 Rules</p><ul><li><strong><code>KylinTableChooserRule</code></strong>: 匹配模型索引（分为明细索引和聚合索引，需要所有的列和聚合算子都能匹配上，默认不会用明细索引回答聚合查询，可通过参数配置）</li><li><strong><code>SegmentPruningRule</code></strong>: 根据分区列和 Filter 条件对 Segment 进行裁剪</li><li><strong><code>PartitionPruningRule</code></strong>: 根据多级分区列筛选分区</li><li><strong><code>RemoveIncapableRealizationsRule</code></strong>: 选择成本最低的 layout</li><li><strong><code>VacantIndexPruningRule(optional)</code></strong>: 选择空的 layout 回答查询</li></ul><p class="note note-info">layout 指的是代码层面的抽象索引（包含多种维度和度量的组合），其实就是 Index。</p><h5 id="3-1-3-Find-the-lowest-cost-candidate"><a href="#3-1-3-Find-the-lowest-cost-candidate" class="headerlink" title="3.1.3 Find the lowest-cost candidate"></a>3.1.3 Find the lowest-cost candidate</h5><p>对所有选出的 layout 应用排序规则后取出最优的回答查询，有时候不一定是成本最低的，比如用户某些场景的特殊需求下，成本最低的 layout 的索引数据是不完整的，Kylin 首先需要保证查询数据的完整性。</p><p>至此，模型匹配的逻辑已经讲述完毕。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a> <a class="hover-with-bg" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/OLAP/">OLAP</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Kylin/">Kylin</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2024/08/19/How-Apache-Kylin-Query-Work%EF%BC%88%E4%BA%8C%EF%BC%89/"><span class="hidden-mobile">How Apache Kylin Query Work（二）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js",(function(){new Valine({el:"#valine",app_id:"gffo4y4h3e1D9tHT2ADcTxtp-gzGzoHsz",app_key:"EaplHXnXAqIYs5wCxGMVB4l4",placeholder:"说点什么",path:window.location.pathname,avatar:"robohash",meta:["nick","mail"],pageSize:"10",lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:""})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><script src="/js/boot.js"></script></body></html>